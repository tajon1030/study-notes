
# 4회차 - MySQL 효율 개선하기 (공유용)

## 1.  indexing

READ 효율을 개선하는 도구
별도의 테이블로 정렬을 관리

### 인덱스를 어디에 거는게 좋을지
**1.  Cardinality**
얼마나 유니크한 값들이 많은지
 - 식당 예약을 예시로
    - 오전 / 오후
    - 고객 성별 남자 / 여자

**2. Update Frequency**
Index 걸어둔 컬럼이 수정되면 index를 관리하는 테이블도 수정필요
하나씩 밀어낸다고 생각해보면?

**3. Size (인덱스 키 값의 크기)**
-   InnoDB - 16KB 단위로 데이터 저장
-   Pointer : 실제는 사이즈의 주소    
-   index key size + pointer size
 
###  인덱스를 충분히 활용할 수 있도록 쿼리를 작성하는 방법들에 대해 논의
1. ORDER BY
2. 쿼리를 잘하려면?
- 기본 쿼리 사용
	- 숫자
	-  날짜
	- 불리언
	- 연산자
	- full table scan
- 인덱스를 잘 사용해야함.


#### TIP
- like검색할때 앞에를 고정시켜야 인덱스를 탄다. -> 앞을 %로 하면 더 오래걸림
- explain을 통해서 실행계획을 확인
- between 과 in의 차이: 
in은 사실 = or = 이기때문에
동등비교가 원래 좀더 빨라서 in이 좋다.

- use index 를 사용하면 실행계획 변경 가능
- ignore index를 사용하면 인덱스 실행계획 무시 가능

- 가급적 바뀌지않는 컬럼에 인덱스를 걸어줘야한다.
(잘 안바뀌면서 read에 자주 쓰이는것)

## 2.  normalization
MySQL이 **중복 데이터를 방지**할 수 있다.
관계형 데이터베이스의 장점

반정규화의 기준은 join할때 성능을 좋게하기위해서...

TIP) 포폴질문에서 db 설계관련해서 질문들어오면
최대한 데이터가 중복되지않으면서 쿼리효율을 높일수있도록 정규화를 잘 했다고 말하도록 한다.

## 3.  partitioning
(개념만 알고 넘어가자)
대용량 테이블을 소규모 테이블로 나누어 저장하는 것   
하지만 사용자는 하나의 테이블로 read/write를 한다고 생각함
늘 좋은 것은 아님
###  파티션의 종류
1. range : 범위로 나누는 것(날짜)
2.  list : 파티션 키가 고정값인 경우(카테고리)
3.  hash : Range, list로 균등하게 데이터를 나누기 어려운 경우
4.  range-hash
5.  range-list

## 4.  cache
자주 쓰는 건 어디다 저장했다가 가져올 수 있다. 
but 8.0부터 사라짐
        -> 1.  이론상으로는 효율에 도움이 된다고 생각했지만 실제 퍼포먼스 측면상 그렇지 않음
        -> 2.  동시성 유지 측면에서 좋지 않음

## 5.  기타 query optimization
