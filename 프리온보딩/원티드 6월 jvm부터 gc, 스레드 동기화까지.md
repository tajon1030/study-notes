# 원티드 6월 jvm부터 gc, 스레드 동기화까지

## 1-1 자바 정의와 동작방식
- JVM과 메모리구조
- 클래스 로딩 등 자바 동작방식
- 바이트코드와 JIT(AOT) 컴파일러
- GC알고리즘
- 스레드 동기화


**참고**
OpenJDK, OracleJDK문서 기준 설명
JDK 17 기준 설명

메모리 구조와 GC 멀티쓰레드 등등 결국 어려운부분에서 기초개념이 없으면 개발할때 문제가 될수 있습니다. 

따라서 이번 포스팅은 자바 정의와 동작방식에 대해서 알아보도록 합니다.



### Java
Write once, run anywhere
고급언어
클래스기반
JVM을 통해 작동
OOP


####  자바가 지키지 못한 순수 객체지향 언어의 특징 :
기본타입이 객체가 아닌 원시타입
static 메서드
wrapper클래스


## Java의 정의와 동작방식
### java 플랫폼
- JDK를 구현한 제품
- Java개발 및 실행환경을 의미
- 흔히 JDK보다 더 넓은 의미로 사용

### JDK
JRE+개발툴

### JRE
실행환경 (JVM + 라이브러리)

### JVM
java 실행 가상머신, 바이트코드 변환
클래스로딩, GC등 메모리관리, 스레드관리, 예외처리 가 대표적인 역할

## 자바 동작방식
javac(java컴파일러)가 클래스를 바이트코드로 바꿔주면 클래스로더가 로딩을 하여 메모리에 적재를하고 메모리영역의 데이터들을 가지고 Execution Engine이 실행을 한다.

JIT컴파일러는 코드를 최적화하여 네이티브코드를 만든다(프로파일링한 정보를 기준으로)

## 클래스로더
loading -> linking -> initialization
클래스로더는 런타임에 바이트코드를 동적으로 메모리에 로딩한다(한번에 모든 클래스가 로드되지않고 필요할때마다 로드)
로딩작업은 크게 세가지로 분리된다.
- Loading: JVM이 필요한 클래스 파일 로드
- Linking: 로드된 클래스의 verify, prepare, resolve 작업 수행(검증 등의 연결)
- initialization: 클래스/정적변수 등 초기화

## JVM Runtime data areas
자료 참고

## Execution Engine
- Interpreter 바이트코드를 한줄씩 해석/실행
- Jit Compiler 프로파일링을 통해 자주쓰이는 메서드(hot method)라면 바이트코드를 네이티브코드로 컴파일
- GC 사용하지않는 개체를 식별해 삭제하는 프로세스(대표적으로 Heap영역)


## JNI
네이티브 라이브러리 사용을 위한 인터페이스이자 동시에 해당 역할을 수행 (일종의 프레임워크)

## Native Method Libraries
라이브러리가 보관되어있는곳

## 컴파일러와 인터프리터
- 컴파일방식: 코드를 타켓언어로 변환하는 프로그램
하이레벨언어를 로우레벨언어로 변환
- 인터프리터: 코드를 직접 분석/실행하는 프로그램


**인터프리터 전략**

1. 코드 구문을 분석, 동작을 직접 수행
2. 코드를 오브젝트코드로 변환
3. 컴파일러에 의해 생성된 바이트 코드를 명시적으로 실행

자바는 두가지 방식을 혼합하여 사용하는 하이브리드 모델이다.
-> javac로 바이트코드로 변환하고
바이트코드를 jvm 인터프리터가 분석하고 실행
일반적으로 컴파일 언어로 분류하는 이유는 javac를 통해 .java파일을 .class파일로 컴파일하기 때문에


## 동작방식 정리
자료참고


# 2. 클래스 로더와 클래스 로딩
## 클래스 로더
필요할때마다 필요한 클래스/리소스만 로딩
런타임에 자바바이트코드를 jvm메모리로 동적로딩
1. 각클래스 로더는상위로더로 위임하며 클래스로딩(캐시된-로딩된 클래스가 있다면 종료)
2. 로딩한 클래스에 문제가 있는지 유효성검사
3. 정적필드메서....발표자료 참고

- 부트스트랩 클래스 로더
최상위 클래스 로더
base 모듈 로딩
- 플랫폼 클래스 로더
java SE platform의 모든 api/클래스 로딩
- 시스템 클래스 로더
클래스패스, 모듈패스에 있는 클래스 로딩

## 좋은 클래스 로더의 속성
- 클래스명이 같다면 클래스로더는 항상 같은 클래스 객체를 반환
- 하위 클래스로더가 상위클래스로더에게 특정 클래스 로딩을 위임한 경우 두 클래스 로더는 해당 클래스에 대해 동일한 객체를 반환해야함
- 클래스로더가 클래스 바이너리(바이트코드)를 미리 가져올때 로딩에러가 발생할 가능성이 있더라도 미리가져올때가 아닌 적시에 가져온다.

## loading
특정이름FQCN을 가진 클래스의 바이트 코드를 찾아 클래스를 만드는 프로세스
- NoClassDefFoundError : 객체를 로딩할때 발생하는 에러
static블록이나 static변수 초기화 시 예외가 발생한 상황에서 발생
- ClassNotFoundException : 클래스패스에서 해당 클래스를 찾을 수 없는 경우 발생

## linking
로딩된 클래스를 실행하기 위해 결합하는 프로세스
바이트코드의 유효성을 검증하고, 선언된 스태틱필드를 초기화(데이터 타입에 맞는 초기값으로 먼저 초기화하고 나중에 initializing단계에서 우리가 선언한값으로 초기화해줌), 필요한 메모리 할당을 하며, 심볼릭 레퍼런스를 실제 참조, 프로세스로 변환하는 작업
OutOfMemoryError가 발생할수있다.

## initialization
클래스/인터페이스의 초기화 메서드 등을 실행하며 초기화


## 바이트코드와 코드 캐시
javac는 jvm이 아니라 jdk의 일부


람다와 익명클래스는 내부적으로 다르게 처리가 된다. 람다의 경우는 invokedynamic

## 코드캐시
JIT컴파일러가 가장 많이 사용함

# 바이트 코드를 컴파일하는 AOT컴파일러, JIT컴파일러
## AOT 컴파일러
자바 바이트코드를 실행전 모두 한번에 컴파일 해두는 방식(워밍업 단축 목표)
바이트코드를 AOT컴파일러를 통해 컴파일 하는 방식 -> 해당기능을 수행하는 Graal컴파일러가 17에서 제거됨

## JIT 컴파일
핫코드일경우에는 JIT컴파일러를 아닐경우 인터프리터를 탄다.
JIT는 프로그램 실행 중에 핫한 바이트코드를 네이티브로 바꾸고 AOT는 실행 전에 네이티브로 바꾼다고 생각하면 맞다.





## 기타 문답들
graalVm 그랄VM : jvm의 구현체중하나로 jdk17에서 빠짐


JDK 가 오라클, 아마존 코레토, 줄루 등 다양하게 제공되는데 왜 하나의 통합된 JDK 를 제공하면 더 합리적일 것 같은데 왜 별도로 제공하는지 알 수 있을까요?
>
JVM은 표준이고, 그것들을 구현한 벤더들이 오라클, 아마존 코레토, 졸루 등이 있는걸로 알고 있습니다.

더불어 JVM벤더로 승인되려면 수만개의 테스트를 통과해야 벤더로 승인되는것으로 알고 있습니다!


음수 표현방식 면접 (2의 보수, 1의 보수 찾아보시면 도움될것 같아요!)


개인적으로 객체지향 개념 잡기에는 [패턴 그리고 객체지향적 코딩의 법칙] 책이 읽기 좋았습니다


성능 테스트 툴로써 개틀링 추천드려요

jvm 스레드와 os스레드의 차이 https://www.geeksforgeeks.org/difference-between-java-threads-and-os-threads/


runtime constant pool이랑 constant pool은 무슨 일을 하는걸까요?

람다 디버깅
