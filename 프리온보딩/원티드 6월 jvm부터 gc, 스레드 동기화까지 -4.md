
# 2-2 동시성 처리를 위한 스레드 동기화에 대해 살펴봅니다.

## 1. 스레드 동기화와 동시성
### 프로그램
프로그래밍 언어로 작성된 명령의 집합. 시퀀스. 셋

### 프로세스
- 프로그램이 메모리에 로딩되어 실행되는 인스턴스. 이 프로세스는 하나 이상의 스레드에 의해 실행됨
- 하나의 프로그램이 여러 프로세스가 될 수 있다.

### 스레드
- 일종의 프로세스 실행단위
- OS마다 스레드 구현이 다르다
- 멀티스레딩 기능을 통해 스레드간 메모리를 포함한 시스템 리소스를 공유할 수 있다.
- 프로세스에 비해 컨텍스트스위칭이 가볍다.

### 프로세스 vs 스레드
- 프로세스는 일종의 프로그램의 실행
	- 일반적으로 프로세스 간 다른 메모리 영역을 소유한다. 즉, 격리된 실행개체로 자체스택, 메모리를 소유
	- 멀티 프로세스 생성은 별도의 시스템 콜이 필요
	- 프로세스 간 통신은 IPC필요(시스템 콜 호출 횟수 증가)
- 스레드는 일종의 세미 프로세스. 자체 스택을 갖고 코드를 실행
	- 일반적으로 스레드 간 메모리 영역을 공유
	- 한번의 시스템 콜을 통해 2개 이상의 스레드 생성 가능
	- 스레드간 통신을 위해 특별한 기술이 필요 없음

### 스레드 사용의 장단점(프로세스와 비교시)
- 장점  
리소스 공유 원활  
실제 멀티코어인 경우 실제로 병렬처리 가능  
프로세스 컨텍스트 스위칭보다 빠름

- 단점  
하나의 스레드가 오작동을 일으키면 리소스 공유로 인해 다른 스레드도 영향을 받음  
서로 다른 시스템에서 실행될 수 없음  

### 자바스레드
- 모든 스레드는 이름을 가지고있고 여러 스레드가 같은 이름을 가질 수 있다.
- 모든 스레드는 우선순위를 갖고있으며 높은경우 우선적으로 실행(무조건 된다는말은 아님)
- 특정 스레드내에 실행되는 코드로 인해 새로운 스레드가 생성되면 새로 생성한 스레드는 생성한 기존스레드와 동일한 우선순위를 가진다.
- 유저스레드와 데몬스레드가 존재한다.
- 스레드 종료 조건  
	- 모든 UserThread가 종료되는경우  
	- run 메서드가 정상적으로 종료되거나 발생한 예외를 처리하지 않은 경우


### Demon Thread
- 우선순위가 낮고 JVM 종료를 막지 않음
(유저쓰레드가 실행되고있으면 JVM이 종료되지않지만 데몬쓰레드가 돌고있더라도 유저쓰레드가 종료되면 JVM도 종료)
- IO작업 등에 사용하는 것을 권장하지 않음(백그라운드에서 돌만한 것들-GC, 메모리해제 등을 사용할 때 추천함. 참고로 대부분의 JVM스레드는 데몬스레드이다.)

### 동시성 vs 병렬처리
- Concurrency  
: 실제로 동시에 실행되지 않음  
- Parallelism  
: 동시에 독립적 작업을 실행하는것  
분산 시스템이나 멀티코어처럼 완전히 격리된 컴퓨터에서 동시에 실행 가능

### Mutex
- 상호배제  
: 레이스 컨디션을 방지하기위해 정의된 동시성 제어 속성
- 한 스레드가 크리티컬 섹션(서로 다른 스레드가 동일한 데이터에 액세스 하는 영역)에 액세스 하는 동안 다른 스레드는 액세스 할 수 없다는것을 의미. 공유 리소스에 액세스 시간의 차이를 의미함

### Semaphore
- 멀티스레드가 공유 리소스에 액세스하는 것을 제어
- 동시성 처리에서 크리티컬 섹션문제를 해결하기 위한 변수, 추상 데이터 타입

### Monitor
- 다음을 충족시키는 동기화 매커니즘  
	- mutex: 락을통해 특정 시점에 단 하나의 스레드만 메서드를 실행할 수 있음  
	- cooperation: wait-set을 통해 특정 조건까지 대기하도록 하는 기능  
- 스레드가 일부 리소스에 액세스하는것을 모니터링하기때문에 모니터라고 부름



### Java Monitor
- synchronized 키워드를 사용해서 크리티컬 섹션을 표현함(synchronized메서드 또는 블락)  
synchronized메서드는 간단히 사용할 수 있고 synchronized블락은 성능 측면에서 효율적  
- 모니터가 객체(인스턴스)와 클래스별로 존재해서 인스턴스와 스태틱 모두 다름  
synchorized 스태틱 메서드의 경우는 모든 인스턴스를 통틀어 특점시점에 하나의 스레드만 실행가능
- 동기화 단계 : 진입/획득/소유/해제/퇴장
- wait메서드, notify메서드

### Java Thread Synchonization
- 스레드 동기화란 멀티스레드환경에서 공유된 자원에 같은 타이밍에 액세스할때 실행순서를 제어하는 프로세스 등을 포괄적으로 의미한다.
- 동시성 문제로 인해 데이터의 일관성이 깨지는 상황들을 모니터 등 다양한 기술을 통해 Synchronization 매커니즘으로 극복한다.
- 각 객체/클래스 별로 모니터를 소유하여 특정시점에 단 하나의 스레드만 액세스 가능하도록 락을 유지. 다른스레드는 블락된 상태로 대기


### Java Thread Life Cycle State
- NEW(실행되지않은상태)
- RUNNABLE(JVM에서 실행중인 상태)
- BLOCKED(모니터 락을 기다리며 차단된 상태)  
: Object.wait()메서드 호출 후 synchronized 블럭(or 메서드)에 진입/재진입을 위해 모니터 락 획득을 기다림  
- WAITING(무작정 기다리는 상태)  
: Object.wait(), Thread.join()  
- TIMED_WAITING(지정 시간까지만 기다리는 상태)
- TERMINATED(스레드 종료)


#### Object클래스의 wait 메서드
- 현재 스레드를 알림notify이나 중단interrupted, 또는 특정시간이 경과할때까지 대기모드로 만듦. 현재 스레드가 이 객체에 모니터 락을 소유하고 있어야함


#### Object클래스의 notify메서드
- 모니터에서 대기상태의 스레드 중 하나(임의선택)를 깨워 활성화 상태가 되도록 선택


## 2. 멀티스레드 환경에서 발생하는 스레드 동기화 문제

### Thread Pool
- Java 스레드는 OS스레드와 매핑되어 무분별하게 생성해서 사용하면 리소스 낭비가 심해진다.
- 멀티스레드를 활용해 병렬작업을 하는것이 효율적이기 때문에 스레드를 관리해주는 스레드 풀 패턴을 활용한다.
- 스레드 풀 사용시엔 병렬 처리 형태로 동시에 수행될 코드를 작성한 후 제출하는 방식으로 사용


#### ForkJoinPool computation Model

#### ForkJoin Framework
- JDK 7 버전에 도입된 프레임워크로 분할 정복 방식으로 병렬 처리 속도를 개선  
	- `fork` 작업으로 적정 수준으로 데이터 소스의 양을 나눠 하위 작업들로 분할  
	- 분할된 작업을 병렬 처리로 수행  
	- `join` 작업으로 분할되었던 작업들을 재귀적으로 병합  
- 스레드 풀로 ForkJoinPool을 사용함

#### Parallet Streams
데이터 소스를 감싸 대량의 데이터의 핸들링을 더욱 편리하게 해주는 프레임워크


### 동기화 문제
- Race Condition : 이벤트 순서에 따라 시스템 상태가 바뀌는 상황  
여러 스레드가 공유 데이터에 접근할 때 발생, 데이터 일관성 에러를 야기함  
- Deadlock : 획득한 리소스의 락을 걸고 다른 프로세스/스레드의 리소스를 무한히 기다리면서 아무것도 진행 못하는 상황  
- LiveLock : 서로의 상태가 엇갈려 실제적으로 비활성 상태는 아니나 프로세스 자체는 비활성 상태인 상황  
- Starvation : 너무 오랫동안 리소스를 획득하지 못하는 경우
- PriorityInversion : 우선 순위가 높은 작업이 낮은 작업으로 대체되어 공유 리소스를 기다리는 상황  
- False Sharing : 잘못된 캐싱 메커니즘에 의해 발생하는 성능 저하

## 3. Java에서 스레드 동기화를 위해 제공하는 기능
### 종류
- Synchronized
- Volatile
- Atomic Class
- Semaphore Class
- ReentrantLock Class
- Locks Class
- ThreadLocal Class

### Synchronized
- 레이스 컨디션이 발생할때 액세스 동기화를 위해 지원하는 매커니즘 중 하나
- 인스턴스메서드/스태틱메서드/코드블록에 사용 가능
- 주의사항
	- 외부에서 락을 걸지 않을 객체들에게만 적용할 것
	- String 리터럴은 풀링 되기 때문에 가급적 적용하지 말 것, 적용해야 한다면 new 키워드와 함께 사용할 것
	- Boolean 리터럴 또한 가급적 적용하지 말 것(인스턴스 공유 때문)
	- 박싱된 원시타입 또한 적용하지 말 것 (클래스를 생성해서 적용할 것) -> JVM이 바이트로 표현할 수 있는 값을 캐싱하여 공유하고 있기 때문
	- this 키워드로 Synchronized를 적용하지 말 것 (락 객체를 따로 구현해 활용) -> JVM은 클래스가 this로 Synchronized를 적용할 때 고유락을 사용함


### Volatile
- 캐싱과 재정렬(reordering) 같은 최적화로 인해 동시 컨텍스트에서 발생하는 문제를 메모리 순서 제어로 해결하기 위한 것
- 메모리 가시성, 재정렬이 부족해 문제가 있음
	- 어떤 값을 업데이트할 때 다른 스레드가 무엇을 볼지에 대한 보장이 없음
	- 재정렬로 인해 실제 처리된 순서가 아닌 다른 순서로 쓰기 값을 볼 수 있음
- 스레드를 동기화 하는 해결책은 아님


### Atomic Variables
- 공유데이터가 가변적인 경우 동시성 처리에서 주의하지않는다면 동시성 오류등이 쉽게 날 수 있음  
- 따라서 Synchronized 키워드를 통해 락 처리 후 연산 (성능 이슈 존재)하거나 원자적 연산 (Atomic Operation)을 사용하는 방법이 있다.


### Semaphore
- 카운팅 세마포어, 공유되는 리소스에 동시성 처리를 제한, 지원하기 위한 클래스. 스레드 수 제한 가능
- 세마포어는 각 스레드가 원하는 요소를 얻기 전에 허가를 얻어 해당 요소를 사용할 수 있음을 보장함
- 상황에 따라 바이너리 세마포어(뮤텍스)로도 사용 가능 but 바이너리 세마포어는 다른 락 구현과 달리 스레드에 의해 락이 해제될 수 있음

### ReentrantLock 리엔트런트락
- 재진입이 가능한 락  
- 마지막 락 획득에 성공한 스레드가 소유  
- 락의 소유권을 획득하는 순서가 공정해도 스레드 스케줄링이 공정하다는 보장은 없음

### ThreadLocal
- 스레드로컬 변수를 제공하는 클래스  
- 스레드 별로 고유하게 보관되며 각 스레드는 복사본 변수를 갖게됨
- 스레드로컬을 스레드 풀과 함께 사용할 때는 주의할 것: 스레드풀은 스레드를 제거하지않기때문에 명시적으로 제거하지않으면 반환되지않고 남아있어서

## 4. JDK 19에 추가된 가상 스레드
### Virtual Thread
- 기존의 Java 스레드는 OS의 스레드와 매핑되는 리소스가 많이 드는 스레드. 따라서 OS 스펙에 영향을 많이 받았으며 컨텍스트 스위칭 등은 성능 부하를 가져옴
- 원래 Java스레드는 기본적으로 OS스레드랑 매핑이 되는데 이건 JVM레벨에서의 스레드. 빠르다
- 경량스레드
- 기존의 스레드를 가상 스레드로 대체하기 위한 것은 아님



