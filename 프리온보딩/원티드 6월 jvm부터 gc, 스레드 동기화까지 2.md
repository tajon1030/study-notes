# jvm 정의와 구조, 메모리에 대해 살펴보기

## 이전 내용 복습
- java는 순수 oop언어라고 볼 수 없을 수 있다.
(java의 원시타입은 객체가 아니고 정적 메서드는 oop에서 안티패턴이라고 보기때문)
- java플랫폼 > jdk > jre > jvm
jvm이 java를 실행하고 메모리관리를 한다.
jre는 jvm+라이브러리. 실행환경
- jvm구조
: 클래스로더(바이트코드를 메모리에 올리는 역할) + Runtime Data Area(메모리) + 실행엔진(메모리 영역에 있는 데이터를 가져와 해당하는 작업 수행. 인터프리터, JIT컴파일러, GC)
- 동작방식
javac(자바컴파일러)가 java코드를 .class파일(바이트코드)로 변환(오브젝트코드로 변환)하면 클래스로더가 이를 메모리에 올려주고 jvm이 os로부터 할당받은 메모리영역(jvm memory)에 올라간 파일을 실행엔진이 작업 수행
- JIT 컴파일러
자바가 인터프리터방식으로 코드를 실행하는데 자주 실행하는 코드인 hot method를 미리 컴파일해서 기계어로 바꾸는 작업을 함
- 클래스로딩
부트스트랩/플랫폼/어플리케이션 클래스로더 -> loading
verify/prepare/resolve(심볼릭레퍼런스를 실제주소값으로 바꾸는 작업) -> linking
static필드의 초기화 : initialization
- 클래스 로딩과정은 최하위 클래스로더(어플리케이션클래스로더)부터 명령이 내려져서 이미 로딩이 되어있는지(캐시되어있는지)확인하여 상위클래스로더에 **위임**하는 방식으로 이루어짐. 상위클래스로더가 해당클래스를 찾지 못하면 요청한 클래스 로더가 찾아서 로딩한다.
- linking
유효성검사, 스태틱필드 기본값초기화, 심볼릭레퍼런스 실제참조, 프로세스등으로 변환
- 런타임 상수 풀
: 메서드 영역에 할당되는 자료구조



## 1. jvm과 메모리구조
총 5개의 구조로 이루어져있다.
method/heap/stack(콜스택 등등의 이름으로 불림)/pc register/native method stack

### pc 레지스터
스레드별로 생성, 실행중인 명령(오프셋)을 저장
현재 실행중인 명령의 주소를 저장

### **jvm stack**
스레드별로 생성. 프레임 저장
로컬 변수 저장과 메서드 호출/반환 등과 같은 작업시 사용(지역변수나 메서드 정보 등)
허용된것보다 더 큰 스택이 필요한 경우 

### **heap**
jvm실행시 생성. 객체 인스턴스/배열에 대한 메모리가 할당(스레드세이프하지않다. gc가 도는 영역)
우리가 주로 사용하게 되는 메모리영역
jvm힙

#### 런타임상수풀
클래스/인스턴스가 로딩될때 메서드 영역에 할당되는 자료구조
일반상수풀의 데이터를 기반으로 생성되며 스태틱상수와 심볼릭레퍼런스 포함

### **method area**
jvm 실행시 생성. 클래스관련정보(클래스 구조, 정보, 메타데이터)를 저장. 런타임상수풀 저장

### native method stack
스레드별로 생성. 네이티브 메서드 데이터가 저장되는 영역


### 생성시점 정리
자료참고

## 2. java 메모리모델과 메모리 누수
### memory model
멀티스레드환경에서 공유되는 데이터를 위해 메모리를 사용하는 방법에 대한 명세


### Shared Multiprocessor Architecture
- 메모리일관성
: 서로 다른 스레드가 하나의 데이터에 접근할때 일관적 상태를 보장하는 속성
=> 별도의 원자적처리가 필요함
또한 프로그래밍 측면에서 하나의 값을 여러 스레드에서 공유하는 형태로 만들지 않는것을 추천

- 메모리 가시성
다른스레드에서 언제 한 스레드에서 변경한 값을 보게될지를 정의한 것

- final filed
별도 동기화 처리가 필요없기때문에 세이프한 불변객체를 지원하여 레지스터에 최종 캐시값을 유지할 수 있다.

- volatile
메인메모리로부터 값을 읽고쓰도록 강제하도록 하는 키워드
여러쓰레드에서 동시에 쓰기작업을 한다면 문제가 발생하기때문에 고유락atomic integer라던지 Intrinsic Lock이나 쓰레드 로컬과 같은것들을 사용해야한다.

### Memory leak
사용하지않는 메모리를 계속 참조해서 발생하는 누수 -> 리소스 낭비, 시스템성능 저하
jvm이 gc를 통해 메모리를 자동으로 관리는 하지만 완벽하지않기때문에 종종 누수가 발생-> 힙영역에서 참조중인 객체를 제거하지않아서 메모리 누수가 발생할수있음
- 스태틱필드 객체로 인한 발생
: 최대한 사용을 지양
- 사용한 리소스를 반환하지않아 발생
: try-with-resources를 통한 해제, 해제하는 코드블록에도 예외가 발생하지않도록 하기
- equals, hashCode메소드를 올바르게 구현하지않아 발생
: 컬렉션에서 불필요한 참조가 발생해서 누수가 발생할수있기때문에 가급적 항상 재정의할것
- 아우터 클래스를 참조하는 이너클래스(non-static)로 인해 발생
: 이너클래스를 사용하기위해 항상 아우터클래스를 참조하기때문에 누수가 발생할수있음 따라서 아우터클래스를 참조하지않는경우 static클래스로 구현할 것
- ThreadLocal클래스로 인해 발생
: remove메서드를 호출하여 명시적으로 참조를 제거할것. 예외상황에서도 finally블록을 통해 제거할것. 값을 비우는데 ThreadLocal.set(null)을 사용하지 말것
- finalize메서드를 통해 발생
- String의 intern으로 인해 발생(jdk6이하일경우)

### 메모리누수 방지
- VisualVM, YourKit등과 같은 프로파일러를 활용한 모니터링
- 참조객체를 통해 방지 -> java.lang.ref패키지에 참조객체 활용
- 벤치마크 활용
- ~~코드리뷰~~

### Memory Optimization Tip
- 컬렉션을 사용할때 다음 사항을 고민해볼것
: 가능하다면 초기사이즈를 지정해 초기화
: 컬렉션별 CRUD에 대한 시간복잡도를 확인해서 의도에 맞는 컬렉션을 사용할 것
: HashMap 사용시 리사이징이 일어나면 해시값을 다시 조정하기때문에 이를 고려할 것
- 가능하다면 특정 객체의 재사용(메모리사용량, GC빈도 등)
: 불변객체나 캐싱형태의 구현을 활용해 볼 것
- 박싱/언박싱을 가급적 피할 것
- StreamAPI 사용시 메모리를 더 사용하거나 성능이 더 느릴 수 있어 주의할 것


## 3. 스레드 덤프를 통한 스레드의 상태 정보 확인
### Thread dump
프로세스의 모든 스레드 상태에 대한 스냅샷

### 4. 힙덤프를 통한 힙 메모리 확인
### Heap dump
특정 순간에 JVM 메모리 상에 있는 모든 객체의 스냅샷
- jmap, VisualVM, OutOfMemoryError 발생시 자동 생성

### APM & Profiling
- APM
: 앱의 성능, 가용성 등을 모니터링 또는 관리하는 것
- Profiling
: 
Newrelic, VisualVM, Scouter, 클라우드 지원 프로파일링 툴 등

차이: Profiling은 코드레벨을 최적화하는데 유용
APM은 앱레벨에서 성능을 모니터링

# 질답
https://docs.google.com/spreadsheets/d/1oqwJts4AK4VN0geUqEtPtFFTCU8UL9AfziO8iYqZqjo/edit#gid=249589912
