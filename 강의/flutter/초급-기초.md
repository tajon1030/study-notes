### 기초적인 플러터 코드 구조
위젯트리 : UI를 렌더링하는데 사용되는 계층구조  
(parent Widget) MaterialApp -> Scaffold -> Center -> Text  (child Widget)  

~~~dart
import 'package:flutter/material.dart';

// 'android/app/build.gradle'

void main() {
  // 플러터 앱을 실행한다
  runApp(
    // 위젯 - 화면에 무언가를 보여주게 하는 요소
    MaterialApp(    // MeterialApp 매테리얼 디자인(플러터에있는 디자인)을 사용할수있게 해주는 위젯
      // MaterialApp은 항상 최상위에 위치한다 (암기)
      debugShowCheckedModeBanner: false, // 오른쪽 상단 디버그 띠 제거
      home: Scaffold(   // Scaffold : 화면에 구조를 만들수있게 해주는 위젯
        // Scaffold는 MaterialApp바로 아래에 위치한다. (암기)
        backgroundColor: Colors.black, // 배경색
        // body: 컨텐츠를 넣을수 있는 부분
        body: Center(   // Center : 가운데정렬위젯
          child: Text(    // Text : 글자를 보여주는 위젯            
            'Code Factory',
            style: TextStyle(
              color: Colors.white, // 텍스트색상
            ),
          ),
        ),
      ),
    ),
  );
}
~~~



### 스플래시 스크린
앱제작시 로딩하거나 시작할때 대기하는동안 보여주는 스크린  
스크린이 보여지는 동안 로그인사용자 검증, 어떤 화면 보여줄지 정하는 로직 실행등이 이루어짐  

#### asset 폴더
앱에서 사용하는 이미지나 특정 파일을 두는 공간  
프로젝트에 asset 폴더를 추가해 준 뒤 pubspec.yml 에서 등록을 해준다.  
~~~yml
flutter:
  assets:
    - asset/img/
~~~

#### 정리
- mainAxisAlignment : 중앙축 기준 정렬  
- children : 여러 위젯을 사용할수있게 해줌  
- CircularProgressIndicator : 동그란 로딩바  
- StatelessWidget : 클래스에 상속받게해서 build함수를 통해 위젯값을 리턴시켜줌(stless단축키) -> hotReload(번개표시버튼)으로 재빌드가능  
- Padding : 여백을 넣어줌. 여기서 EdgeInsets.symmetric를 사용하여 대칭을 이루도록 여백 생성 가능  
- SizedBox : 기본값이 투명해서 간격을 둘때 padding대신 사용하기도 함  

~~~dart
import 'package:flutter/material.dart';

void main() {
  runApp(
    MaterialApp(home: HomeWidget()),
  );
}

class HomeWidget extends StatelessWidget {
  const HomeWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Color(0xff78c72e),
      body: Padding(
        padding: EdgeInsets.symmetric(horizontal: 30.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Image.asset('asset/img/logo.png'),
            SizedBox(
              height: 28.0,
            ),
            CircularProgressIndicator(
              color: Colors.white,
            ),
          ],
        ),
      ),
    );
  }
}

~~~

### Row, Column
- Row : 가로로 위젯을 배치할때 사용  
- Column : 세로로 위젯을 배치할때 사용  
- MainAxisAlignment : 주축  
- CrossAxisAlginment : 반대축  

특별한 제한사항이 없다면 Row, Column위젯의 주축은 최대크기를 차지하고,  
반대축은 최소크기를 차지한다.  

#### MainAxisAlignment 옵션들  
- start 시작정렬  
- end 끝정렬  
- center 중앙정렬  
- spaceBetween 자식이 양끝에 있고, 위젯 **사이** 동일한 간격  
- spaceAround 양끝은 n만큼, 위젯사이는 2n만큼의 간격  
- spaceEvenly 양끝, 위젯사이 n만큼의 간격  

#### CrossAxisAlignment 옵션들
- start  
- end  
- center  
- stretch 위젯들을 최대로 확장  
- baseline 텍스트 기준선을 기준으로 위젯 정렬  

#### 위젯  
- Container : 다른 위젯을 담는 위젯, 디자인요소를 넣을수있음  
- SafeArea : 상태바등을 제외한 나머지위젯에서부터 위젯이 시작되도록 한다. 주로 스케폴드 바디 최상단에 입력  
- Expanded : Colunm 또는 Row 안에서 남는 공간을 전부다 최대한 차지(여러개사용하면 비율을 똑같이 차지하도록, 비율을 다르게하고싶다면 flex 옵션 사용)  
- Flexible : fit옵션을 이용하여 Flexible위젯이 차지하는만큼 형제위젯이 차지할수있도록 할수있냐 없냐를 결정할수있음(FlexFit.tight로 하면 Expanded와 동일)  

~~~dart  
import 'package:flutter/material.dart';

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Container(
          color: Colors.black,
          height: double.infinity,
          child: Column(children: [
            Flexible(
              flex: 2,
              fit: FlexFit.tight,
              child: Container(
                height: 50.0,
                width: 50.0,
                color: Colors.red,
              ),
            ),
            Expanded(
              child: Container(
                height: 50.0,
                width: 50.0,
                color: Colors.orange,
              ),
            ),
            Expanded(
              child: Container(
                height: 50.0,
                width: 50.0,
                color: Colors.yellow,
              ),
            ),
          ]),
        ),
      ),
    );
  }
}

~~~

~~~dart
import 'package:flutter/material.dart';

const colors = [
  Colors.red,
  Colors.orange,
  Colors.yellow,
  Colors.green
];
~~~  
~~~dart
import 'package:flutter/material.dart';

import '../const/colors.dart';

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: colors
                  .map((e) => Container(
                        color: e,
                        height: 50,
                        width: 50,
                      ))
                  .toList(),
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Container(
                  width: 50,
                  height: 50,
                  color: Colors.orange,
                )
              ],
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: colors
                  .map((e) => Container(
                        color: e,
                        height: 50,
                        width: 50,
                      ))
                  .toList(),
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Container(
                  color: Colors.green,
                  width: 50,
                  height: 50,
                )
              ],
            ),
          ],
        ),
      ),
    );
  }
}

~~~

### Padding
- EdgeInsets.all() : 상하좌우에 동일값 추가  
- EdgeInsets.symmetric() : 대칭으로 추가  
- EdgeInsets.only() : 상화좌우 커스텀 추가(named parameter)  
- EdgeInsets.fromLTRB() : 상하좌우 커스텀추가(무조건 왼위오아순서)  

### 블로그 웹앱 예제  
#### AppBar  
상단 제목(안드로이드는 좌기본 ios는 가운데 기본)  
라우트스택 안에 이전 라우트가 있을경우 자동으로 뒤로가기 버튼이 만들어짐
옵션 centerTitle: true 가운데정렬, false 왼쪽정렬  

#### 외부패키지
Pub.dev 사이트에서 원하는 패키지 pubspec.yml(dependencies)에 추가   

#### 시멘틱 버저닝(sementic versioning)  
소프트웨어 버전관리의 표준화된 규칙  
[Major].[Minor].[Patch]  
- Major : 하위호환성을 깨뜨리는 중요한 변경이 있을경우. 주로 기존 api의 변경이나 기능의 큰 변화  
- Minor : 하위호환성을 유지하면서 기능이 추가될경우.  
- Patch : 하위호환성을 유지하면서 기존기능 버그 수정할 경우  

마이너 버전 업덷이트가 아니라면 패키지 사용방법이 변하지않고, ^을 사용하여 메이저버전 업데이트외의 모든 버전은 최신버전으로 유지할수있다. ex)^4.3.2  


#### 웹뷰
웹사이트를 볼수있는 위젯  
ios는 기본적으로 js활성화  
안드로이드 비활성화 -> setJavaScriptMode()  

#### WebViewController  
웹뷰를 제어하기위한 클래스  
주요메서드 : loadUrl, loadData, reload, goBack  

~~~dart
// 콜백함수이용하여 홈으로 이동하기
import 'package:flutter/material.dart';
import 'package:webview_flutter/webview_flutter.dart';

final homeUrl = Uri.parse('https://github.com/tajon1030');

class HomeScreen extends StatelessWidget {
  WebViewController controller = WebViewController()
    ..setJavaScriptMode(JavaScriptMode.disabled)
    ..loadRequest(homeUrl); // ..점두개: 함수를 실행한 '대상'을 반환

  HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.green,
        title: Text('Code Factory'),
        centerTitle: true,
        actions: [ // 앱바 오른쪽에 위젯 삽입
          IconButton( 
            onPressed: () {
              print('pressed');
              controller.loadRequest(homeUrl);
            },
            icon: Icon(Icons.home), // Icons 기본정의 아이콘
          ),
        ],
      ),
      body: WebViewWidget(
        controller: controller,
      ),
    );
  }
}

~~~  

### StatefulWidget
위젯 : 화면에 보여지는 클래스로 표현한 요소  
UI를 표현하는 위젯의 두가지 구분: Stateless/Stateful Widget  
위젯은 **불변** -> 새로생성하려면 build함수를 재실행해야함  
HotReload는 개발자도구에서 사용하므로 다른 방법이 필요 -> setState함수는 빌드를 재실행(statefulWidget에 있음)  

참고) 플러터 처음 실행될때에는 빌드가 두번일어남  

~~~dart
import 'package:flutter/material.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  Color color = Colors.blue;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        width: double.infinity,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ElevatedButton(
              onPressed: () {
                if(color == Colors.blue){
                  color = Colors.red;
                }else{
                  color = Colors.blue;
                }
                setState(() {
                });
                print('색상변경 color : $color');
              },
              child: Text('색상변경 color'),
            ),
            SizedBox(
              height: 32.0,
            ),
            Container(
              width: 50.0,
              height: 50.0,
              color: color,
            )
          ],
        ),
      ),
    );
  }
}
~~~

### 위젯 라이프 사이클(매우중요!! 암기)
#### StatelessWidget 라이프사이클
constructor()->build()  

#### StatefulWidget 라이프사이클
StatefulWidget클래스] Constructor()->createState()->  
State클래스] initState()->didChangeDependencies()->dirty->build()->clean (->setState() -> dirty-> build() -> clean -> ...)  
->deactivate()->dispose()  

#### 재실행때
Constructor() -> didUpdateWidget() -> dirty -> build() -> clean -> ...

#### 정리
- createState() : 처음생성할때 실행. 재실행시에는 기존에 존재하던 State클래스를 찾아서 기존존재하던 상태를 그대로 유지할수있음  
- initState() : 생성자와 거의 똑같은기능으로 인스턴스화됏을때 한번만 실행/context를 사용하지못함  
- didChangeDependencies() : State클래스가 의존하고있는 의존성이 변경됏을때 다시 실행  
ex)Theme.of, MediaQuery.of  
- dirty/clean : State클래스의 상태(빌드가 실행되기바로전후의 상태)  
- deactivate(), dispose() : State클래스가 사라질경우 순서대로 실행  
- didUpdateWidget() : 재실행시에 기존 존재하던 State위젯을 찾고나서 업데이트가됐는지 알아보는 함수  

참고) **State클래스는 Widget클래스의 변수를 제공해줌(widget.xxx)**  

~~~dart
import 'package:flutter/material.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  bool show = false;
  Color color = Colors.red;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SizedBox(
        width: double.infinity,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            if (show)
              GestureDetector(
                child: CodeFactoryWidget(color: color),
                onTap: (){
                  setState(() {
                    color = color == Colors.blue ? Colors.red : Colors.blue;
                  });
                },
              ),
            SizedBox(
              height: 32,
            ),
            ElevatedButton(
                onPressed: () {
                  setState(() {
                    show = !show;
                  });
                },
                child: Text('클릭해서 보이기/안보이기'))
          ],
        ),
      ),
    );
  }
}

class CodeFactoryWidget extends StatefulWidget {
  final Color color;

  CodeFactoryWidget({super.key, required this.color}) {
    print('1) Stateful Widget Constructor');
  }

  @override
  State<CodeFactoryWidget> createState() {
    print('2) Stateful Widget createState');
    return _CodeFactoryWidgetState();
  }
}

class _CodeFactoryWidgetState extends State<CodeFactoryWidget> {
  @override
  void initState() {
    print('3) Stateful Widget initState');
    super.initState();
  }

  @override
  void didChangeDependencies() {
    print('4) Stateful Widget didChangeDependencies');
    super.didChangeDependencies();
  }

  @override
  Widget build(BuildContext context) {
    print('5) Stateful Widget build');
    return Container(
      width: 50,
      height: 50,
      color: widget.color,
    );
  }

  @override
  void deactivate() {
    print('6) Stateful Widget deactivate');
    super.deactivate();
  }

  @override
  void dispose() {
    print('7) Stateful Widget dispose');
    super.dispose();
  }
}

~~~


### 전자액자 예제
#### Timer
지정한 시간이 지난뒤 한번 또는 주기적으로 실행할수있게 함  
기본 제공 dart:async 패키지에 있음  

~~~dart
import 'dart:async';
  
void main(){
  Timer(
    Duration(seconds: 1),
    () {
      print('1초뒤에 실행한다!');
    },
  );
  
  int number = 0;

  Timer.periodic(
    Duration(seconds: 1) ,
    (Timer timer){
      number++;
      print('1초마다 실행된다!');
      
      if(number > 5){
        timer.cancel();
      }
    }
  );
}
~~~

### PageView  
여러페이지를 한화면에서 보여줄 경우 사용  
~~~dart
    return Scaffold(
      body: PageView(
        children: [1, 2, 3, 4, 5]
            .map((e) => Image.asset(
                  'asset/img/image_$e.jpeg',
                  fit: BoxFit.cover,
                ))
            .toList(),
      ),
    );
~~~

Controller와 Timer를 사용할때에는 꼭 dispose를 함께 사용해줘야한다  

~~~dart
// 2초마다 다음 페이지로 슬라이드되는 페이지
import 'dart:async';

import 'package:flutter/material.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  Timer? timer;
  PageController controller = PageController();

  @override
  void initState() {
    super.initState();

    timer = Timer.periodic(
      Duration(seconds: 2),
      (timer) {
        int currentPage = controller.page!.toInt();
        int nextPage = currentPage + 1;

        if (nextPage > 4) {
          nextPage = 0;
        }

        controller.animateToPage(
          nextPage,
          duration: Duration(milliseconds: 500),
          curve: Curves.linear,
        );
      },
    );
  }

  @override
  void dispose() {
    if(timer != null){
      timer!.cancel();
    }
    controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: PageView(
        controller: controller,
        children: [1, 2, 3, 4, 5]
            .map((e) => Image.asset(
                  'asset/img/image_$e.jpeg',
                  fit: BoxFit.cover,
                ))
            .toList(),
      ),
    );
  }
}
~~~

### 날짜, 기간
- DateTime 날짜 : 연도만 필수  
- Duration 기간 : namedParameter  
~~~dart
void main() {
  final date = DateTime(1996);
  final date2 = DateTime(1996, 3);
  final utcDate = date.toUtc();
  final duration = Duration(days: 1, hours: 23);

  print(date.isAfter(date2));
  print(date.add(duration));
  print(date.subtract(duration));
  print(date.isAtSameMomentAs(date2));
  print(date);
  print(utcDate);
  print(utcDate.toLocal());
}
~~~

### 우리 사귄지 몇일 예제
#### 폰트
GoogleFonts에서 다운받아서 추가 가능  
pubspec.yml에 설정추가함  
~~~yml
  fonts:
    - family: parisienne
      fonts:
        - asset: asset/font/Parisienne-Regular.ttf
    - family: sunflower
      fonts:
        - asset: asset/font/Sunflower-Light.ttf
        - asset: asset/font/Sunflower-Medium.ttf
          weight: 500
        - asset: asset/font/Sunflower-Bold.ttf
          weight: 700
~~~

#### SizedBox
단순히 크기를 정하기 위한 위젯  
`double.infinity` 할수도 있지만  
`MediaQuery.of(context).size.width`을 사용하면 실행기기의 전체 width를 알수있음  

#### SafeArea
노치나 시스템관련부분을 제외한 영역  

#### ThemeData
style 속성을 따로 빼서 작성할수있음  
작성한 테마는 Theme.of(context).textTheme.displayLarge 와 같은 방식으로 사용 가능함  

#### showCupertinoDialog()
애플기반(cupertino)의 다이얼로그  
위젯은 어디로 정렬되어야 하는지 모른다면 높이/너비를 지정하더라도 전체 최대사이즈를 차지하게 된다. -> Align으로 감싸서 정렬기준 추가  

#### CupertinoDatePicker
날짜를 고를수 있는 위젯  


### Constraint
위젯의 위치와 사이즈에 대한 제약  
- SinglePass
- Constraints Go Down
- Sizes Go Up
- Parent Sets Position

#### 제한사항들
- 자식위젯은 부모가 제한하고있는 제약 내에서만 크기를 가져갈수있다  
- 위젯의 위치는 부모가 지정하기때문에 자신이 정확히 어디에 위치할지 알수없다(x,y좌표로 위젯을 배치하지않는 이유)
- 자식위젯이 **어디에 정렬되야하는지** 정확히알수없는경우 자식위젯의 **크기가 무시**될수있다(중요)

### Alignment
Align위젯의 alignment속성에서 Alignment.center, Alignment.bottmLeft, Alignment(x,y) 등의 값을 이용해서 정렬 시킬 수 있음  

### 랜덤숫자생성기 예제
- 난수생성
- 하나이상의 페이지 사용
- Slider사용
- map()함수 사용

#### Route Stack
RouteStack에 스크린들을 겹겹이 관리하게되는데 스택구조로 이루어져있음  
스크린을 이동시킬때에는 다음과 같이 push(), pop()으로 사용  
데이터를 주고받을때 pop함수 안에 리턴할값을 넣어주고  
push 함수를 await해서 값을 받으면 된다  
~~~dart
// home_screen.dart
  onSettingIconPressed() async {
    final result = await Navigator.of(context).push(
      MaterialPageRoute(
        builder: (BuildContext context) {
          return SettingScreen();
        },
      ),
    );

    maxNumber = result;
  }
// setting_screen.dart
  onSavePressed() {
    Navigator.of(context).pop(
      maxNumber.toInt(),
    );
  }
~~~
- context : 위젯트리에 대한 정보를 가지고 있으며  
이동할때 위젯트리가 어떻게 구성되어있는지 코드상에서 알아야하기때문에 Navigator.of에 context를 넣어줌  
- Navigator.of(context).push()에서 MaterialPageRoute라는 클래스의 도움을 받아야하는 이유  
스크린A와 스크린B사이에 데이터를 전송하고 받아야할 경우가 있기 때문  
- stateless위젯에서는 context를 위젯안에서 전역적으로 사용 불가 -> 파라미터를 통해서 넘겨줘야함  
stateful위젯에서는 전역적으로 context 사용 가능  
- build함수는 context를 파라미터로 제공해주고 그려내고싶은 위젯을 반환해주는 함수역할을 함  


### BuildContext
Q. 하나의 위젯은 자신이 위젯트리 어디에 위치하는지 어떻게 알까?   
A. StatelessWidget과 StatefulWidget은 모두 Widget을 상속받는다.  
=> Widget클래스 정의에는 createElement() 함수가 있다  
=> createElement()란 element를 만드는 역할을 한다.  
=> element는 위젯의 정보를 들고있고, parent, children, size 와 같은, 위젯트리안에서 어떤위젯을 어떻게(크기, 부모자식관계) 그려낼지에 대해서 알고있다  
=> Element는 BuildContext를 implement하고있다.
=> 따라서 **BuildContext는 위젯트리에서의 위젯의 위치정보를 들고있다.**  
=> 따라서 mediaQuery 등을 사용할때 위젯트리에 대한 정보를 알고있어야하는것이기때문에 BuildContext를 인자로 넣어줌


### Buttons
- ElevatedButton  
- OutlinedButton  
- TextButton  
셋다 버튼인데 기본스타일링이 다름  
모든 파라미터는 똑같이 정의됨  

~~~dart
ElevatedButton(
              onPressed: () {}, // null 입력하면 disabled로 바뀜
              child: Text('ElevatedButton'),
              style: ElevatedButton.styleFrom(
                /// 배경색
                backgroundColor: Colors.red,
                disabledBackgroundColor: Colors.grey,

                /// 배경위의 색
                foregroundColor: Colors.white,
                disabledForegroundColor: Colors.red,
                elevation: 10,
                /// 그림자크기
                shadowColor: Colors.green,
                textStyle: TextStyle(
                  fontWeight: FontWeight.w700,
                  fontSize: 20,
                ),
                padding: EdgeInsets.all(30),
                side: BorderSide(width: 13),
//                minimumSize: Size(300, 150),
//                maximumSize: Size(100, 150),
//                fixedSize: Size(100, 150)
              ),
            ),
~~~

#### ButtonStyle 과 ElevatedButton.styleFrom
ButtonStyle에서는 MaterialStateProperty.all()와 같이 호버링됐을경우나 클릭했을 경우등에 딸른 스타일을 지정할 수 있음  
간단하게 기본 스타일을 지정하려면 그냥 ElevatedButton.styleFrom 사용
~~~dart
style: ButtonStyle(
                  backgroundColor: MaterialStateProperty.all(Colors.red),
)
~~~
~~~dart
style: ButtonStyle(
                  backgroundColor: MaterialStateProperty.resolveWith(
                        (Set<MaterialState> states) {
                      if (states.contains(MaterialState.pressed)) {
                        return Colors.red;
                      } else {
                        return Colors.black;
                      }
                    },
                  ),
)
~~~

Flutter 2.0부터 MaterialStateProperty가 deprecated된 상태기때문에 WidgetStateProperty로 변경하여 사용하자  

#### iconButton
ElevatedButton.icon() 과같이 버튼뒤에 icon을 달아서 사용하면 파라미터로 icon을 넣을수있음  
~~~dart
            ElevatedButton.icon(
              onPressed: () {},
              icon: Icon(Icons.keyboard_alt_outlined),
              label: Text('키보드'),
            )
~~~


### Navigation
데이터를 다음페이지로 보내는 두가지 방법  
1. 파라미터로 보내는방법  
~~~dart
class RouteOneScreen extends StatelessWidget {
  final int number; // 상위로부터 받을 변수값

  // required로 선언
  const RouteOneScreen({required this.number, super.key});

  @override
  Widget build(BuildContext context) {
    return DefaultLayout(
      title: 'RouteOneScreen',
      children: [
        Text(
	  // 사용시에는 $를 사용
          'argument: $number',
          textAlign: TextAlign.center,
        ),
        OutlinedButton(
          onPressed: () {
	    // 상위로 되돌려줄때에는 pop안에 변수값을 넣어줌
            Navigator.of(context).pop(456,);
          },
          child: Text('Pop'),
        ),
      ],
    );
  }
}
~~~
~~~dart
        OutlinedButton(
	 // 하위로부터 변수를 돌려받을때에는 async와 await를 사용
          onPressed: () async {
            final result = await Navigator.of(context).push(
              // builder 에는 BuildContext를 파라미터로 가지는
              // 리턴하고싶은 위젯을 반환하는 함수를 넣는다
              MaterialPageRoute(
                builder: (BuildContext context) {
		  // 파라미터로 보내고싶은 변수를 담아서 보내줌
                  return RouteOneScreen(number: 20);
                },
              ),
            );
          },
          child: Text('Push'),
        ),
~~~

2. settings로 보내는방법  
MaterialPageRoute에는 builder말고도 settings라는 변수가 존재함  
여기들어가는 RouteSettings클래스에 arguments 값을 이용해서 값을 전달가능 함  
~~~dart
OutlinedButton(
          onPressed: () {
            Navigator.of(context).push(
              MaterialPageRoute(
                  builder: (BuildContext context) {
                    return RouteTwoScreen();
                  },
                  settings: RouteSettings(arguments: 789)),
            );
          },
          child: Text('Push'),
        ),
~~~

~~~dart
class RouteTwoScreen extends StatelessWidget {
  const RouteTwoScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // 받을때는 ModalRoute.of를 사용해서 받을 수 있다.
    final arguments = ModalRoute.of(context)?.settings.arguments;
...
~~~


#### Decclarative Routing과 NamedRoutes
- Imperative Routing : 코드상에서 어디로 갈지 직접 입력해주는것 ex)Navigate  
- Declarative Routing : 미리 라우트를 정해놓고 라우팅 하는 방식  
~~~dart
void main() {
  runApp(
    MaterialApp(
      initialRoute: '/',
      routes: {
        /// key - 라우트이름
        /// value - builder함수 : 이동하고싶은 라우트 반환
        '/': (BuildContext context) => HomeScreen(),
        '/one': (BuildContext context) => RouteOneScreen(
              number: 999,
            ),
        '/two': (BuildContext context) => RouteTwoScreen(),
        '/three': (BuildContext context) => RouteThreeScreen(),
      },
    ),
  );
}
~~~
~~~dart
        OutlinedButton(
          onPressed: () {
            Navigator.of(context).pushNamed(
              '/three',
              arguments: 111111,
            );
          },
          child: Text('Push Route Three'),
        ),
~~~
앞에서 파라미터로 값을 전달해줄수있음에도 불구하고 settings를 이용해서 arguments를 보낸 이유는  
Declarative Router로 이동을 할때 arguments를 꼭 사용해서 값을 전달해줘야하기때문에 그렇다.  

#### pushReplacement, pushReplacementNamed
push할때 가장위에있는 스택의 스크린을 빼고 새로운 스크린을 넣어줌  
~~~dart
        OutlinedButton(
          onPressed: () {
            Navigator.of(context).pushReplacement(MaterialPageRoute(
              builder: (BuildContext context) {
                return RouteThreeScreen();
              },
              settings: RouteSettings(
                arguments: 222,
              ),
            ));
          },
          child: Text('Push Replacement'),
        )
~~~

#### pushAndRemoveUntil  
아래 예제는 홈화면일경우를 제외하고 모든 라우트를 삭제한다.  
~~~dart
         OutlinedButton(
          onPressed: () {
            Navigator.of(context).pushNamedAndRemoveUntil(
              '/three',
              (route) {
                /// 삭제를 할거면 (Route Stack) false 반환
                /// 삭제를 안할거면 true반환
                return route.settings.name == '/';
              },
              arguments: 999,
            );
          },
          child: Text('Push Named And Remove Until'),
        )
~~~

#### maybePop
pop하려는 스크린이 마지막 스크린일 경우에   유지  
~~~dart
            Navigator.of(context).maybePop(456);
~~~

#### canPop
pop을 할수 있는지 없는지를 반환  
~~~dart
            Navigator.of(context).canPop();
~~~

#### popScope
PopScope위젯의 canPop옵션을 이용하여 시스템에서 제공해주는 뒤로가기 기능을 못쓰게함  
~~~dart
    PopScope(
      canPop: false,
      child: ...
    )
~~~

### VideoPlayer
#### copyWith
기존에 설정한 TextStyle에 copyWith를 통해 새로운 스타일을 추가해줄수있음  
~~~dart
Widget build(BuildContext context) {
    final textStyle = TextStyle(
      color: Colors.white,
      fontSize: 32,
    );

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text(
          'VIDEO',
          style: textStyle.copyWith(
            fontWeight: FontWeight.w300,
          ),
        ),
...
~~~

#### Gradient 배경
Container에는 decoration이라는 옵션이 있는데 여기서 BoxDecoration이라는것을 사용해서 gradient값에 LinearGradient나 RadialGradient를 사용하면 위에서 아래로 색이 점진적으로 변하도록 만들 수 있음  
~~~dart
Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [Color(0xFF2A3A7C), Color(0xFF000118)]),
        ),
	child : ...
~~~

#### Ternary Operator로 위젯 스위칭
pubspec.yaml의 dependencies에 video_player: ^2.8.2 추가(동영상을 보여줌)  
child안에 액션이 생겼을때 GestureDetector는 감지하게 해준다.  
~~~dart
/// Logo의 child를 눌렀을경우에 onTap이라는 콜백함수가 실행되도록 한다.
class _Logo extends StatelessWidget {
  final VoidCallback onTap;

  const _Logo({required this.onTap, super.key});

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Image.asset(
        'asset/image/logo.png',
      ),
    );
  }
}
~~~

#### 동영상 선택 기능
pubspec.yml에서 image_picker dependency 추가해주면 이미지, 영상을 선택할수있음  
XFilel
~~~dart
class _HomeScreenState extends State<HomeScreen> {
  XFile? video; /// null일수도?

  @override
  Widget build(BuildContext context) {
    return Scaffold(
        body: video != null
            ? _VideoPlayer(
                /// null이 아님!
                video: video!,
              )
            : _VideoSelector(
                onLogoTap: onLogoTap,
              ));
  }

  onLogoTap() async {
    final video = await ImagePicker().pickVideo(
      source: ImageSource.gallery,
    );

    setState(() {
      this.video = video;
    });
  }
}
~~~

#### 화면에 동영상 보여주기
AspectRatio를 사용하여 동영상의 비율대로 화면에 나타나도록 해줌  
VideoPlayer와 VideoPlayerController를 이용하면 동영상을 보여줄 수 있다.  
VideoPlayerController는 실행되는 영상의 상태값들을 알아낼수도 있다.  
~~~dart
class _VideoPlayerState extends State<_VideoPlayer> {
  late final VideoPlayerController videoPlayerController;

  @override
  void initState() {
    super.initState();
    initializeController();
  }

  initializeController() async {
    videoPlayerController = VideoPlayerController.file(
      File(widget.video.path),
    );
    await videoPlayerController.initialize();
    // 초기화된 상태 반영
    setState(() {});
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: AspectRatio(
          aspectRatio: videoPlayerController.value.aspectRatio,
          child: VideoPlayer(videoPlayerController)),
    );
  }
}
~~~

#### Stack 사용해서 영상위에 아이콘 배치하기
- stack : 동영상위에 동영상을 컨트롤할 수 있는 버튼들을 올려줄때 사용   
- slider : 동영상 상태줄 표기시 사용
- positoined : align 대신 위치를 설정해줄때 사용(stack안에서 유용)
- align : 위치설정(정렬)
~~~dart
Widget build(BuildContext context) {
    return Center(
      child: AspectRatio(
          aspectRatio: videoPlayerController.value.aspectRatio,
          child: Stack(children: [
            VideoPlayer(videoPlayerController),
            Align(
              alignment: Alignment.center,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  IconButton(
                    onPressed: () {},
                    icon: Icon(Icons.rotate_left),
                    color: Colors.white,
                  ),
                  IconButton(
                    onPressed: () {},
                    icon: Icon(Icons.play_arrow),
                    color: Colors.white,
                  ),
                  IconButton(
                    onPressed: () {},
                    icon: Icon(Icons.rotate_right),
                    color: Colors.white,
                  ),
                ],
              ),
            ),
            Positioned(
              bottom: 0,
              left: 0,
              right: 0,
              child: Slider(
                value: 0,
                onChanged: (double val) {},
              ),
            ),
            Positioned(
              right: 0,
              child: IconButton(
                onPressed: () {},
                icon: Icon(Icons.photo_camera_back),
                color: Colors.white,
              ),
            )
          ])),
    );
~~~

#### 실행중지버튼
실행중지버튼을 나타내기위해서 현재상태가 실행중인지 중지중인지 알아야하는데 이때 VideoController의 value.isPlaying을 통해 해당값을 알아 낼 수 있고,  
play와 pause 함수를 이용해서 동영상을 재생.중지 시킬수있음  
아이콘도 바꿔주기위해서는 setState를 통해 빌드를 재실행해줘야한다.  
~~~dart
                  IconButton(
                    onPressed: () {
                      setState(() {
                        if (videoPlayerController.value.isPlaying) {
                          videoPlayerController.pause();
                        } else {
                          videoPlayerController.play();
                        }
                      });
                    },
                    icon: Icon(
                      videoPlayerController.value.isPlaying
                          ? Icons.pause
                          : Icons.play_arrow,
                    ),
                    color: Colors.white,
                  ),
~~~

#### 동영상상태바
videoPlayerController에서 addListener를 통해서 무언가가 변경될때마다(영상이 재생되고있는지 등) 콜백함수를 실행해줌 -> 위에서처럼 일일히 아이콘이나 상태바마다 setState해주지않아도 되고 그냥 콜백함수에 setState를 설정해주면 됨  
상태바에서 현재위치를 지정해줄때에는 videoPlayerController.value.position.inSecons를 이용하면 현재 초단위 길이를 지정해줄수있고,  
최대길이로는 videoPlayerController.value.duration.inSeconds 를 이용하면 동영상의 길이를 구할 수 있음  
~~~dart
  initializeController() async {
    videoPlayerController = VideoPlayerController.file(
      File(widget.video.path),
    );
    await videoPlayerController.initialize();
    videoPlayerController.addListener(() {
      setState(() {});
    });

    setState(() {});
  }
~~~
~~~dart
            Positioned(
              bottom: 0,
              left: 0,
              right: 0,
              child: Slider(
                max: videoPlayerController.value.duration.inSeconds.toDouble(),
                value:
                    videoPlayerController.value.position.inSeconds.toDouble(),
                onChanged: (double val) {},
              ),
            ),
~~~

### 출퇴근 확인 앱
- Geolocator : 위경도를 사용한 각종 계산 및 현재 내 위치를 알수있게 해주는 플러그인  
- Google Maps
- Marker
- Circle
- Stream
- FuterBuilder
- Permission

#### 화면에 GoogleMaps 보여주기
- LatLng : 위경도 지정  
- Geolocator.isLocationServiceEnabled() : 위치기능 활성화 여부  
- Geolocator.checkPermission() : 권한 확인  
- 권한은 항상 기본은 거절상태  
- Geolocator.requestPermission() : 권한 요청  
- FutureBuilder : 비동기 처리를 한 후 위젯을 반환할때 사용(=Future값에 의해 화면을 렌더링할때 씀. 그냥 build함수에서는 비동기를 사용할 수 없음)  
~~~dart
...
class _HomeScreenState extends State<HomeScreen> {
  final CameraPosition initialPosition =
      CameraPosition(target: LatLng(37.5493, 127.0818), zoom: 15);

  checkPermission() async {
    final isLocationEnabled = await Geolocator.isLocationServiceEnabled();
    if (!isLocationEnabled) {
      throw Exception('위치 기능을 활성화 해주세요');
    }

    LocationPermission checkedPermission = await Geolocator.checkPermission();
    // 기본거부상태 denied
    if (checkedPermission == LocationPermission.denied) {
      checkedPermission = await Geolocator.requestPermission();
    }
    if (checkedPermission != LocationPermission.always &&
        checkedPermission != LocationPermission.whileInUse) {
      throw Exception('위치 권한을 허가 해주세요');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: FutureBuilder(
        future: checkPermission(), // 어떤함수를 실행하고싶은지
        builder: (BuildContext context, AsyncSnapshot snapshot){
        // future의 결과를 받을수있는곳 snapshot
          if(snapshot.hasError){
            return Center(
              child: Text(snapshot.error.toString()),
            );
          }
          return Column(children: [
            Expanded(
                child: GoogleMap(
                  initialCameraPosition: initialPosition,
                )),
          ]);
        },
      )
    );
  }
~~~


#### 내위치 이동시키기
지도를 움직일수있는 작업  
controller : 코드에서 UI기능의 무언가를 작동시키기위해서 사용  
-> 지도를 이동시키기 위해서는 GoogleMapController를 사용함  
onMapCreated 함수는 googleMapController를 파라미터로 받을 수 있어서 이걸통해서 state에 googleMapController를 저장할수있음  
-> controller.animateCamera를 통해서 지도화면을 이동시킬수있음  
~~~dart
class _HomeScreenState extends State<HomeScreen> {
  late final GoogleMapController controller;
  ...
  @override
  Widget build(BuildContext context) {
    return Scaffold(
        appBar: AppBar(
	...
          actions: [
            IconButton(
              onPressed: myLocationPressed,
              icon: Icon(Icons.my_location),
              color: Colors.blue,
            )
          ],
        ),
        body: FutureBuilder(
		...
            return Column(children: [
              Expanded(
                child: GoogleMap(
                  initialCameraPosition: initialPosition,
                  myLocationEnabled: true,
                  myLocationButtonEnabled: false,
                  onMapCreated: (GoogleMapController controller) {
                    this.controller = controller;
                  },
                ),
              ),
            ]);
          },
        ));
  }

  myLocationPressed() async {
    final location = await Geolocator.getCurrentPosition();
    controller.animateCamera(
        CameraUpdate.newLatLng(LatLng(location.latitude, location.longitude)));
  }
~~~

#### 구글map 원과 마크 그리기
마크 : markers  
원 : circles  
파라미터를 사용하여 그릴 수 있음  
~~~dart
                child: GoogleMap(
                  initialCameraPosition: initialPosition,
                  myLocationEnabled: true,
                  myLocationButtonEnabled: false,
                  onMapCreated: (GoogleMapController controller) {
                    this.controller = controller;
                  },
                  markers: {
                    Marker(
                      markerId: MarkerId('123'),
                      position: LatLng(37.5493, 127.0818),
                    )
                  },
                  circles: {
                    Circle(
                      circleId: CircleId('inDistance'),
                      center: LatLng(
                          37.5493, 127.0818
                      ),
                      radius: 100,
                      fillColor: Colors.blue.withOpacity(0.5),
                      strokeColor: Colors.blue,
                      strokeWidth: 1,
                    )
                  },
                ),
~~~

#### 출첵로직 작성
- dialog는 하나의 페이지를 인식하기때문에 Navigator.of(context).pop()을 하면 dialog를 지울 수 있다.  
- 거리에 따라 출근 가능 혹은 불가능을 설정하기위해서는 위젯의 initState에서 스트림에서 값을 계속 받도록 한번만 리슨해주면 된다.  
~~~dart
...
class _HomeScreenState extends State<HomeScreen> {
...
  @override
  void initState() {
    super.initState();
    // 스트림에서 앱을 실행하고 종료될때까지 계속 값을 받을거기때문에 initState에서 한번만 리슨해줌
    Geolocator.getPositionStream().listen((event) {
      final start = LatLng(37.5493, 127.0818);
      final end = LatLng(event.latitude, event.longitude);
      final distance = Geolocator.distanceBetween(
          start.latitude, start.longitude, end.latitude, end.longitude);

      setState(() {
        if (distance > okDistance) {
          canChoolcheck = false;
        } else {
          canChoolcheck = true;
        }
      });
    });
  }
~~~

### FutureBuilder & StreamBuilder
#### FutureBuilder
 future로 주어진 함수의 값이 반환이 될때마다(정확하게는 상태가 바뀔때마다) 빌더를 새로 실행하게 된다.  
여러번 다시실행된다고 퍼포먼스가 떨어지는것이 아니기때문에 걱정할 필요 없음  
캐싱기능이 있음  
- ConnectionState.none; -> Future 또는 Stream이 입력되지 않은 상태
- ConnectionState.active; -> Stream에서만 존재 / 스트림 아직 실행중
- ConnectionState.done; -> Future 또는 Stream이 종료됐을때
- ConnectionState.waiting; -> 실행중

#### StreamBuilder
ConnectionState가 계속 active상태이고, 마지막값까지 반환되고 스트림이 끝나면 done이 됨  
async*와 yield 를 사용  
(async*는 stream을 반환하고, yield는 데이터를 중간중간 반환한다)  
~~~dart
class _HomeScreenState extends State<HomeScreen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
        body: StreamBuilder<int>(
      stream: streamNumbers(),
      builder: (BuildContext context, AsyncSnapshot<int> snapshot) {
        if (snapshot.connectionState == ConnectionState.active) {
          /// 로딩중인데 데이터가 있는 상태일경우?
          /// 다른 위젯을 보여준다
          return SizedBox(
            width: double.infinity,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                CircularProgressIndicator(),
                Text(snapshot.data.toString()),
              ],
            ),
          );
        }

        /// error 확인
        if (snapshot.hasError) {
          final error = snapshot.error;
          return Center(
            child: Text(error.toString()),
          );
        }
        if (snapshot.hasData) {
          final data = snapshot.data;
          return Center(
            child: Text(data.toString()),
          );
        }
        return Center(
          child: Text('데이터가 없습니다.'),
        );
      },
    ));
  }

  Future<int> getNumber() async {
    await Future.delayed(Duration(seconds: 3));
    final random = Random();
    return random.nextInt(100);
  }

  Stream<int> streamNumbers() async* {
    for(int i=0; i<10; i++){
      await Future.delayed(Duration(seconds: 1));
      yield i;
    }
  }
}
~~~

### 영상통화 프로젝트
- Agora : 영상통화 서버 제공(agora_rtc_engine 패키지)
- BoxShadow
- Permissions : 카메라와 오디오 권한을 받아올 것(플러터에서 많이쓰는 권한관련 패키지(permission_handler)
- Stack : 위젯을 위로 쌓는다.  
 
아고라 테스트를 위한 연결 : https://webdemo.agora.io/basicVideoCall/index.html  

permisson_handler패키지를 이용하면 다음과 같이 권한을 받을 수 있음  
~~~dart
    final resp = await [Permission.camera, Permission.microphone].request();
~~~

### 일정관리앱
- Table Calendar : 달력 관련 패키지
- Drift
- Dismissible
- BottomSheet : 아래에서 위로 올라오는 창
- Form

#### TableCalendar
- firstDay : 달력의 최소날짜
- lastDay : 달력의 최대날짜
- focusedDay : 포커스날짜(색상표시)
- selectedDay : 선택한 날짜
- selectedDayPredicate : DateTime을 파라미터로 가지는 함수로 true,false를 리턴하여 특정날짜가 포커스가 되도록 해줄수있음(파라미터로 받은 DateTime값이 특정값이 되는 경우에만 포커스)  
스타일설정시 BoxDecoration을 정해줄때 선택한날짜의 디자인에 BorderRadius가 설정되있을경우 선택해서 이동하려는 날짜에도 BorderRadius가 적용되어있어야함을 주의해야한다.  
~~~dart
...
class _HomeScreenState extends State<HomeScreen> {
  DateTime? selectedDay;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: TableCalendar(
        firstDay: DateTime(2020, 1, 1),
        lastDay: DateTime(2030, 12, 31),
        focusedDay: DateTime.now(),
        onDaySelected: (DateTime selectedDay, DateTime focusedDay) {
          print(selectedDay);
          print(focusedDay);
          setState(() {
            this.selectedDay = selectedDay;
          });
        },
        selectedDayPredicate: (day) {
          if (selectedDay == null) {
            return false;
          }
          return day.isAtSameMomentAs(selectedDay!);
        },
      ),
    );
  }
~~~


#### 국제화 패키지 intl
pubspec.yml에 intl 패키지를 넣어주고 main함수에서 다음과 같이 설정한다.   
table_calendar에서는 내부적인 설정이 다되어있기때문에 그냥 locale 값만 넣어주면 된다.  
~~~data
import 'package:flutter/material.dart';
import 'package:intl/date_symbol_data_local.dart';
import 'package:route_one_screen/screen/home_screen.dart';

void main() async {
  // 프레임워크가 실행할 준비가 되어있는지 확인하는 절차
  // main함수에서 runApp말고 다른함수를 먼저 실행하면 직접 해당 함수를 호출해줘야함
  WidgetsFlutterBinding.ensureInitialized();

  await initializeDateFormatting();

  runApp(
    MaterialApp(
      home: HomeScreen(),
    ),
  );
}
~~~
~~~dart
...
        child: TableCalendar(
          locale: 'ko_KR', // 한국어 로케일
...
~~~

#### ScheduleCard 만들기
- ListView를 사용해서 스크롤할수있도록 위젯 스택 쌓을수있음  
- Row를 IntrinsicHeight(IntrinsicWidth) 위젯으로 감싸면 Row위젯에서 가장 큰 공간을 차지하는 위젯의 높이(너비)에 맞쳐서 최대높이(너비)를 맞춰줌(사이즈를 지정해주지않았을경우)  
~~~dart
        child: IntrinsicHeight(
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    '${startTime.hour.toString().padLeft(2, '0')}:00',
                    style: TextStyle(
                      fontWeight: FontWeight.w600,
                      color: primaryColor,
                      fontSize: 16,
                    ),
                  ),
                  Text(
                    '${endTime.hour.toString().padLeft(2, '0')}:00',
                    style: TextStyle(
                      fontWeight: FontWeight.w600,
                      color: primaryColor,
                      fontSize: 10,
                    ),
                  ),
                ],
              ),
              SizedBox(
                width: 16,
              ),
              Expanded(
                child: Text(content),
              ),
              Container(
                decoration: BoxDecoration(
                  color: color,
                  shape: BoxShape.circle,
                ),
                width: 16,
                height: 16,
              ),
            ],
          ),
        ),
~~~ 

#### bottomSheet
하단에서 올라오는 위젯dmfh floatingActionButton버튼으로 하단에 버튼을 생성하고  
onPressed됐을때 showModalBottomSheet가 실행되도록한다.  
showModalBottomSheet에서 builder함수가 들어가는데 여기서는 bottomSheet에서 사용할 위젯을 리턴시켜주면 된다.
~~~dart
    return Scaffold(
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          showModalBottomSheet(
            context: context,
            builder: (_) {
              return Container(
                color: Colors.white,
                height: 600,
                child: Column(
                  children: [
                    
                  ],
                ),
              );
            }, // bottomsheet에서 사용할 위젯을 넣어주면 됨
          );
        },
        backgroundColor: primaryColor,
        child: Icon(
          Icons.add,
          color: Colors.white,
        ),
      ),
~~~

#### TextFormField
텍스트를 입력할수있는 폼  
색상을 지정할때에는 decoration필드에 InputDecoration을 넣어주는데 이때 filled: true속성을 줘야 fillColor색상이 적용된다.  
~~~dart
                    TextFormField(
                      decoration: InputDecoration(
                        filled: true,
                        fillColor: Colors.grey[300],
                        border: InputBorder.none,
                      ),
                      cursorColor: Colors.grey,
                     )
~~~
- TextFormField(TextField도 마찬가지)를 세로로 늘리고 싶을 경우 : Column안에서  TextFormField를 Expand로 감싸주고 enabled를 true로 넣어줘야함  
enabled가 false로 들어올때에는 min/maxLineds값을 null이 아니게 지정해줘야한다.  
~~~dart
		...
                  child: Column(
                    children: [
                      Row(...),                      ),
                      Expanded(
                        child: CustomTextField(
                          label: '내용',
                          expand: true,
                        ),
                      ),
                    ],
                  ),
~~~  
~~~dart
class CustomTextField extends StatelessWidget {
  final String label;
  final bool expand;

  const CustomTextField({super.key, required this.label, this.expand = false});

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: TextStyle(
            fontWeight: FontWeight.w600,
            color: primaryColor,
          ),
        ),
        if (expand) Expanded(child: renderTextFormField()),
        if (!expand) renderTextFormField(),
      ],
    );
  }

  renderTextFormField() {
    return TextFormField(
      decoration: InputDecoration(
        filled: true,
        fillColor: Colors.grey[300],
        border: InputBorder.none,
      ),
      enabled: expand,
      maxLines: expand ? null : 1,
      // 텍스트라인에 입력을할때 최대/최소 줄의 갯수로 null을 넣으면 작성하는대로 늘어날 수 있음
      minLines: expand ? null : 1,
      cursorColor: Colors.grey,
    );
  }
}
~~~