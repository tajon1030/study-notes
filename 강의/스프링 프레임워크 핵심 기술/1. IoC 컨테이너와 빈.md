## 3. IoC 컨테이너 1부: 스프링 IoC 컨테이너와 빈
Inversion of Control: 의존 관계 주입(Dependency Injection)이라고도 하며,  
어떤 객체가 사용하는 의존 객체를 직접 만들어 사용하는게 아니라, 생성자를 사용하여 **주입 받아** 사용하는 방법을 말함.

### 스프링 IoC 컨테이너
직접적으로 생성자를 사용하여 의존객체를 주입할수도있지만 IoC컨테이너를 주로 이용함  
- BeanFactory(IoC컨테이너의 가장 핵심적인 클래스)  
- 애플리케이션 컴포넌트의 중앙 저장소.  
- 빈 설정 소스로 부터 빈 정의를 읽어들이고, 빈을 구성하고 제공한다.  

### 빈
- 스프링 IoC 컨테이너가 관리 하는 객체.  
- 장점  
	- 의존성 관리 : 의존성주입을 하려면 빈으로 등록해야함  
	- 스코프 : 기본적으로 싱글톤으로 객체를 만들어 관리하여 항상 같은 객체를 주입받을수있어서 효율적이고 런타임시 성능최적화에도 유리하다.  
	- 라이프사이클 인터페이스 지원(ex-빈이 만들어졌을때 하고싶은 행위를 @PostConstruct를 이용해서 작성할수도 있음)  

### ApplicationContext
- BeanFactory를 상속받아 우리가 실질적으로 사용하는 IoC컨테이너
- 메시지 소스 처리 기능 (i18n) - 메세지다국화 기능을 가지고있음
- 이벤트 발행 기능
- 리소스 로딩 기능



## 4. IoC 컨테이너 2부: ApplicationContext와 다양한 빈 설정 방법  
### 스프링 IoC 컨테이너의 역할
- 빈 인스턴스 생성  
- 의존 관계 설정  
- 빈 제공  

스프링 IoC컨테이너는 빈설정파일이 있어야함  

### 빈 설정
- 빈 명세서
- 빈에 대한 정의를 담고 있다.
	- 이름
	- 클래스
	- 스코프
	- 생성자 아규먼트 (constructor)
	- 프로퍼트 (setter)


#### xml설정방식(고전방식)  
~~~xml
<bean id="studentRepository" class="pakageName.StudentRepository">
<bean id="registerService" class="pakageName.StudentRegisterService">
  <const ructor-arg ref="studentRepository"/>
</bean>
~~~  

일일히 등록하는게 귀찮아서 나온방식이 component-scan  
특정 패키지 이하의 모든 클래스 중에 @Component 애노테이션을 사용한 클래스를 빈으로 자동으로 등록 해 줌. (이를 확장받은 애노테이션들 - @Service,@Repository 등..)   
~~~xml
<context:component-scan base-package="packageName"/>
~~~  

#### 자바설정파일
ApplicationConfig라고 @Configuration 빈설정파일을 만들어서 해당 설정파일에 @Bean을 통해서 빈을 등록할수있음  
~~~java
 @Configuration
 public class ApplicationConfig{
 
     @Bean
     public BookRepository bookRepository(){
 	    return new BookRepository();
     }
     @Bean
     public BookService bookService(){
 	    BookService bookService = new BookService();
 	    bookService.setBookRepository(bookRepository());
 	    return bookService;
     }
}
~~~

컴포넌트스캔을 자바설정으로 하는방법
@Component를 사용한 클래스들을 @ComponentScan을 통해서 읽어들인다.  
~~~java
@Configuration
//@ComponentScan(basePackages={"pakageName"})
// basePackages는 typeSafe하지않기때문에 basePackageClasses를 이용해도 좋음
// basePakageClasses의 경우 class가 위치한 곳부터 하위패키지-클래스의 모든 어노테이션이 부여된 class를 빈으로 등록한다
@ComponentScan(basePackageClasses=Application.class)
public class ApplicationConfig {
}
~~~

### AppcliationContext
main함수에서 다음과 같이 선언  
- ClassPathXmlApplicationContext (XML)   
~~~java
ApplicationContext context = 
    new ClassPathXmlApplicationContext(configLocation="applicationContext.xml");
~~~

- AnnotationConfigApplicationContext (Java)  
~~~java
  ApplicationContext context =
      new AnnotationConfigApplicationContext(ApplicationConfig.class);
~~~

스프링부트에 가서는 위 설정들을 @SpringBootApplication에서 다 해줌  
@SpringBootApplication가 달린 클래스 자체가 빈설정파일이라고 볼수있다.  


## 5. IoC 컨테이너 3부: @Autowire  
필요한 의존 객체의 “타입"에 해당하는 빈을 찾아 주입한다.  

### @Autowired
required 옵션이 있는데 기본값은 true이다.  
만약 빈이 없을경우 애플리케이션 구동에 실패하며 만약 의존성이 반드시 필요한 것이 아니라면 @Autowired(required=false)를 이용하여 구동시킬수 있다.  

### 사용할 수 있는 위치
- 생성자 (스프링 4.3 부터는 생략 가능)
- 세터
- 필드

### 경우의 수
- 해당 타입의 빈이 없는 경우
- 해당 타입의 빈이 한 개인 경우
- 해당 타입의 빈이 여러 개인 경우  
	- 빈 이름으로 시도,  
		- 같은 이름의 빈 찾으면 해당 빈 사용  
		- 같은 이름 못 찾으면 실패  

### 같은 타입의 빈이 여러개 일 때 해결책 3가지
동일한 객체가 2개 이상인 경우 같은 이름의 빈을 찾으면 해당 빈을 사용하고, 그렇지 않으면 자동주입대상객체를 판단하지 못해서 exception을 발생시킨다.  

- @Primary  
- 해당 타입의 빈 모두 주입 받기  
- @Qualifier (빈 이름으로 주입)  

세가지 방법중 한 방법을 이용해서 문제를 해결할 수 있다.  
Qualifier보다는 Primary가 타입세이프하니까 Primary를 추천함  


## 6. IoC 컨테이너 4부: @Component와 컴포넌트 스캔
### 컨포넌트 스캔 주요 기능
- 스캔 위치 설정(basePackage, basePackageClasses)  
- 필터: 어떤 애노테이션을 스캔 할지 또는 하지 않을지 걸러주는 옵션이 존재함  

### ComponentScan 대상들
다음 어노테이션들은 내부적으로 @Component 어노테이션을 가지고있음  
- @Repository
- @Service
- @Controller
- @Configuration

### 동작 원리
@ComponentScan은 스캔할 패키지와 애노테이션에 대한 정보를 가지고  
ConfigurationClassPostProcessor라는 BeanFactoryPostProcessor에 의해 다른모든빈들이 만들어지기 이전에 적용을 해줘서 스캐닝 처리 됨.  

### 펑션을 사용한 빈 등록  
프로그래밍적 컨트롤이 가능한 방식으로 애플리케이션 구동 시 성능상 이점이 있음  
(리플렉션이나 CGLibrary같은것들을 안쓰니까)  
~~~java  
@Autowired
MyService myService;

public static void main(String[] args) {
	new SpringApplicationBuilder()
		.sources(Demospring51Application.class)
		.initializers((ApplicationContextInitializer<GenericApplicationContext>) applicationContext -> {
			applicationContext.registerBean(MyService.class);
		})
		.run(args);
}
~~~


## 7. IoC 컨테이너 5부: 빈의 스코프
### 스코프
- 싱글톤(빈의 기본스코프) : 애플리케이션 전반에 걸쳐 빈의 인스턴스가 오직 한개  
- 프로토타입  
	- Request  
	- Session  
	- WebSocket  
	- ...  

~~~java  
// 매번 다른 인스턴스를 가질것임
@Component @Scope("prototype")
public class Proto{}
~~~

### 프로토타입 빈이 싱글톤 빈을 참조하면?
아무 문제 없음.  

### 싱글톤 빈이 프로토타입 빈을 참조하면?
싱글톤은 인스턴스가 한번만만들어지는데 만들어질때 프로토타입스콥의 프로퍼티도 이미 셋팅이된다.  
그렇기때문에 싱글톤 빈을 계속 쓸때 프로토타입스콥의 프로퍼티가 변경되지않는다.  
즉, 프로토타입 빈이 업데이트가 안되네?  
- 업데이트 하려면 프록시 모드 설정 
	- 1. scoped-proxy  
	- 2. ObjectProvider(비추)  
	- 3. Provider (표준)  

~~~java
@Component @Scope("prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class Proto{}
~~~

기본값은 디폴트(ScopedProxyMode.DEFAULT)로 프록시를 사용하지않는다는 옵션  
예시는 클래스에 있기때문에 TARGET_CLASS로 설정해주었음  
(다른빈들이 사용할때 해당빈(Proto)은 클래스기반의 프록시로 감싸라(프록시빈을 쓰게해라 라는 의미) -> 싱글인스턴스가 프로토타입의 스코프빈을 직접참조하면 안되기때문-안그러면 매번 새로운 인스턴스로 바꿔주는 것이 불가능  
타겟클래스를 사용할 경우 CG라이브러리를 사용한 다이나믹프록시를 적용  

### 프록시
https://en.wikipedia.org/wiki/Proxy_pattern  

### 싱글톤 객체 사용시 주의할 점
- 프로퍼티가 공유된다.(프로퍼티가 스레드세이프할거라고 보장받을수없음)  
- ApplicationContext 초기 구동시 인스턴스가 생성된다.  
