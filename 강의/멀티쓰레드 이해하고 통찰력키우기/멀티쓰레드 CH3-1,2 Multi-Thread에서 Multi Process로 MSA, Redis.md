# Backend 멀티쓰레드 이해하고 통찰력 키우기  
섹션3 : Multi-Thread에서 Multi Process로~ 통찰력 키우기(코드_c#)  

## MicroService Architecture - Process 여러 개면 여러모로 좋아
### Scale-Up, Scale-Out
트래픽이 늘어났을때  
- scale-up : 서버머신 스펙 높이기  
- scale-out : 서버머신 수 늘리기  

유저가 많아지면 머신의 스펙업으로는 해결이 안된다.  
분산저장 분산처리를 위해 NoSQL로 Scale out을 시도할수있는데 RDB로 스케일업하는만큼의 비용이 발생할 수 있고 리스크대비 소득이 없을 수 있다는 단점->잘알고 사용을 해야한다.  

### 멀티프로세스
- MSA 여러머신에 여러 프로세스가 있는 형태로 독립적인 기능들을 프로세스로 만들어서 실행함  

### 프로세스간 통신
프로세스간의 통신은 메모리 공유가 안되기때문에  
Http + Json 을 사용함(쉽지만 느리다)  
혹은 TCP + Custom Protocol 을 사용함  

### MSA의 장점
서버부하정도에 따라 머신의 갯수나 프로세스의 위치같은것들을 코드수정없이 가변적으로 변경시킬수있다  
유저가 늘어남에따라 코드를 변경하지않아도 됨

### 프로세스의 단위
- 프로세스를 너무 잘게쪼개면 복잡도가 상승하고 너무 크게만들면 후에 쪼갤때 고생을 해야한다. => 같은 프로세스를 기능에 따라 다른 머신으로 분리한다.  

## Redis 파헤치기 - 겉 핥기 말고 속 핥기
### Redis란?
인메모리스토리지로 저장장치를 쓰는 RDB에 비해 빠르다.  
key-value, 위치기반 검색, 랭킹, 큐스택구현가능, transaction지원, TTL지원등의 다양한 기능을 제공한다.  

### 레디스 주요기능
- Snapshot : 지속적으로 무중단 저장장치에 저장 가능  
- Replication : 다른 노드에 복제가 가능  
- Redis Cluster : 여러대의 redis로 분산 저장 및 처리가 가능  
- ThreadModel : Node.js Thread Model과 유사하다.  
메인쓰레드가 하나있고 모든 처리를 그 쓰레드에서 다 하는데 특별한경우(시간이 오래걸리는경우)만 별도의 스레드나 프로세스를 만들어서 처리를 하는 것  
- Redis vs MemcacheD : redis를 더 많이 사용함  

### Redis Cluster
redis client(웹서버쯤?)가 요청하려는 키를 해시함수를 돌려 나온 값으로 노드를 찾아서 저장함  
=> 데이터 복제본을 replica에 저장  
=> 다른프로젝트의 경우 리플리카없이 다른노드에 복제본을 저장하기도 한다.  

### Redis Thread Model
대부분의 명령어들은 싱글쓰레드로 동작하여 먼저온요청이 먼저 처리되는것이 보장  
암호화관련, File IO관련 작업은 별도의 쓰레드에서 작업  

### Redis Command는 Atomic한가?
Atomic Operation이 맞다.  

### Redis Cluster 장애상황에서?
master 노드에 장애가 생긴경우
replica가 있으면 replica node가 마스터로 승격됨  
없는경우 장애가 생긴 노드를 복구하거나 새로운 노드를 추가해야하고 그전까지는 해당 노드에서 다루던 데이터들이 접근 불가하다.  

### Redis 트랜잭션 지원하는가?
트랜잭션을 지원하며 CAS방식과 유사하다(compare and swap)  
WATCH로 데이터를 옵저빙하고(데이터가 바뀌는지 안바뀌는지)  
MULTI로 트랜잭션 시작  
EXEC로 커밋을하고  
DISCARD를 호출하면 롤백이 된다.  

### Redis 트랜잭션 실패1
커밋이 실패를 하는경우에 유저에게 다시실행하라는 에러를 리턴한다.  
제일 구현이 간편하지만 UX상으로는 조금 불편하다.  

### Redis 트랜잭션 실패2  
서버에서 성공할때까지 재시도를 하는데,  
timeout 구현해야하기때문에 코드가 복잡해지고 Timeout이 발생할만큼 계속 실패한다면 설계부터 다시하는게 맞다.  
UX상으로는 좀더 낫다.  

### Redis Replication 방식
비동기식으로 리플리케이션을 한다.  

#### 비동기식 복제가 뜻하는 의미
master에 있는 데이터가 특정 순간에 replica와 다를수도 있다는 의미  
master노드에 장애가 발생하여 replica가 master로 승격됐을때 replica는 오래된 데이터일 수 있다.  

#### 오래된 데이터문제
쓰기는 master에서하고 read는 replica에서 한다면 read는 오래된 데이터를 읽을 수 있다.  
이 경우 가시성을 확보하려면 WAIT 명령어를 사용하여 모두 복제가 되었는지 확인할 수 있지만 느리다.  

### 고려할사항1
master에 쓰기를 한 request는 변경된 값을 return 하기 위해 replica에서 read하여 리턴해주면 안된다.(이전데이터를 read할수있음)  
변경된값을 redis가 리턴해주면 그걸 써야한다.  

### 고려할사항2
완전히 복제되기까지 단순 read request는 오래된 데이터를 읽을수있다는것을 인정하는것  
비동기식 시스템이 많아지면서 유저들도 오래된 데이터가 나오면 refresh 연타하기때문에 괜찮을수있다~

### 고려할사항3
무조건 최신 데이터를 replica에서 읽어야한다면 master에서 읽어와야한다.  
replica에서 무조건 최신 데이터를 읽도록 구현하려고하면 복잡해지고 느릴수밖에 없음  

### Pub/Sub기능
Subscribe명령어로 특정채널을 구독하고 Publish명령어로 구독한 Connection에 메세지를 보내는것  
but 이전메시지를 가져올수없다.  

#### 뭐가문제인가  
메시지를 받아서 어떤 처리를 해야하는데 실패할경우 메시지를 저장하지않아서 재시도가 불가능하다.  

#### 어떨때 적절한가? - 시나리오
내 웹서버는 서버가 뜰때 한번 redis에서 db와 ip/port를 가져옴  
redis에 있는 데이터를변경하면 현재 실행중인 서버에 알려주고싶다면  
실행중인 서버들은 새로운 ip와 port를 적용하여 connection을 재생성한다.  

