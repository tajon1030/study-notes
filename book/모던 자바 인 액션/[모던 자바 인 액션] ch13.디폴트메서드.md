# 모던 자바 인 액션

## Part 4. 매일 자바와 함께
### chapter 13. 디폴트 메서드
#### 13.1 변화하는 API
라이브러리설계자가 새로운 메서드를 추가하는 등 인터페이스를 바꾸고 싶을때 문제가 발생한다.  

문제점  
1. 해당 인터페이스를 구현하는 모든 클래스가 새로운 메서드를 구현해야한다.  
-> 새로 추가된 메서드를 호출하지만 않으면 새로운 메서드 구현이 없이도 기존 클래스 파일 구현이 잘 동작하지만(바이너리호환성)  
누군가 나중에 코드를 새로운 메서드를 사용하도록 한다면 오류가 발생할것이다.  
2. 전체 애플리케이션을 재빌드할때 컴파일 에러가 발생한다.  

버전을 예전버전과 새로운 버전을 나눠 직접관리할수있지만 관리가 복잡하고 이전버전과 새로운버전을 모두 사용해야하는 문제  
이를 디폴트메서드를 통해 해결할 수 있다.  

참고) 바이너리호환성, 소스호환성, 동작호환성  
- 바이너리 호환성: 뭔가를 바꾼 이후에도 에러없이 기존 바이너리가 실행
- 소스호환성: 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일 가능
- 동작 호환성 : 코드를 바꾼 다음에도 같은 입력값이 주어지면 프로그램이 같은 동작을 실행

#### 13.2 디폴트메서드란 무엇인가?
호환성을 유지하면서 API를 바꿀수있도록 하는 새로운 기능  
default 키워드로 시작  
메서드 바디를 포함  

~~~java
public interface Sized{
    int size();
    default boolean isEmpty(){
        return size() == 0;
    }
}
~~~

참고) 추상클래스와 인터페이스  
1. 클래스는 하나의 추상클래스만 상속받을수있지만 인터페이스를 여러개 구현할 수 있다.  
2. 추상클래스는 인스턴스변수(필드)를 공통상태를 가질수있다. 인터페이스는 가질수없음  

#### 13.3 디폴트 메서드 활용 패턴
##### 13.3.1 선택형메서드
Iterator인터페이스의 경우 remove메서드도 정의하지만 사용자들은 해당 기능을 잘 사용하지않기때문에  
Iterator를 구현하는 많은 클래스에서 remove에 빈 구현을 제공했다.  
디폴트 메서드를 이용하면 기본구현을 제공할수있으므로 인터페이스를 구현하는 클래스에서 빈구현을 만들 필요가 없다.  
~~~java
interface Iterator<T>{
    boolean hasNext();
    T next();
    default void remove() {
        throw new UnsupportedOperationException();
    }
}
~~~  
##### 13.3.2 동작 다중 상속
클래스는 여러 인터페이스를 구현할수있기때문에  
인터페이스를 조합해서 다양한 클래스를 구현할 수 있다.  

#### 13.4 해석 규칙
같은 시그니처를 갖는 디폴트 메서드를 상속받는 상황에서의 충돌은 어떻게 해결할까
##### 13.4.1 세가지 해결규칙
1. 클래스가 항상 이긴다. 클래스나 슈퍼클래스에서 정의한 메서드가 디폴트메서드보다 우선권을 가짐  
2. 규칙1 이외의 상황에서는 서브인터페이스가 이긴다. 상속관계를 갖는 인터페이스에서 같은 시그니처를 갖는 메서드를 정의할때에는 서브인터페이스가 이긴다. 즉, B가 A를 상속받는다면 B가 이긴다.  
3. 여전히 디폴트메서드의 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스가 명시적으로 디폴트메서드를 오버라이드하고 호출해야한다.  

##### 13.4.2 예제1
~~~java
public interface A{
    default void hello(){
        System.out.println("Hello from A");
    }
}

public interface B extends A{
    default void hello(){
        System.out.println("Hello from B");
    }
}

public class D implements A{}
public class C extends D implements B, A{
    public static void main(String... args){
        new C().hello();
    }
}
~~~  
위와 같은 코드일 경우 D가 A를 오버라이드하지않고 단순히 인터페이스 A를 구현했으므로 클래스의 메서드구현이 없는상태이기때문에  
2번규칙을 따라서 디폴트메서드를 정의하는 서브인터페이스가 선택되어 인터페이스B의 hello를 따르게된다.  
만약 D가 명시적으로 A의 hello 메서드를 오버라이드한다면 D의 메서드를 따르게될것이다.  

##### 13.4.3 예제2
명시적으로 오버라이드해야하는 경우 X.super.m(...) 형태로 구현한다.  
~~~java
public interface A{
    default void hello(){
        System.out.println("Hello from A");
    }
}

public interface B{
    default void hello(){
        System.out.println("Hello from B");
    }
}

public class C implements B,A{
    void hello(){
        B.super.hello();
    }
}
~~~

#### 13.5 마치며
- 자바8의 인터페이스는 구현 코드를 포함하는 디폴트 메서드, 정적 메서드를 정의할 수 있다.
- 디폴트 메서드의 정의는 default 키워드로 시작하며 일반 클래스 메서드처럼 바디를 갖는다.
- 공개된 인터페이스에 추상 메서드를 추가하면 소스 호환성이 깨진다.
- 디폴트 메서드 덕분에 라이브러리 설계자가 API를 바꿔도 기존 버전과 호환성을 유지할 수 있다.
- 선택형 메서드와 동작 다중 상속에도 디폴트 메서드를 사용할 수 있다.
- 클래스가 같은 시그니처를 갖는 여러 디폴트 메서드를 상속하면서 생기는 충돌 문제를 해결하는 규칙이 있다.
- 클래스나 슈퍼클래스에 정의된 메서드가 다른 디폴트 메서드 정의보다 우선한다. 이 외의 상황에서는 서브인터페이스에서 제공하는 디폴트 메서드가 선택된다.
- 두 메서드의 시그니처가 같고, 상속관계로도 충돌문제를 해결할 수 없을때는 디폴트 메서드를 사용하는 클래스에서 메서드를 오버라이드해서 어떤 디폴트 메서드를 호출할지 명시적으로 결정해야한다.