# 가상 면접 사례로 배우는 대규모 시스템 설계 기초

## chapter 4. 처리율 제한 장치의 설계
처리율제한장치 : 클라이언트/서비스가 보내는 트래픽의 처리율을 제어하기위한 장치  
ex) 특정 기간내 전송되는 클라이언트의 요청횟수를 제한(크롤링 제한 등에 쓰임)  

### API에 처리율 제한 장치를 뒀을때 장점  
1. Dos 공격에 의한 자원 고갈을 방지할 수 있다.  
2. 비용을 절감할수있다. (api과금횟수)
3. 서버과부화를 막는다  

### 1단계 문제 이해 및 설계 범위 확정
고민해야할점에는 다음과 같은 점들이 있다.  
- 클라이언트측 제한인지 서버측 제한인지
- 어떤 기준을 사용해서 api 호출을 제한해야하는가(ip주소/사용자id)
- 시스템 규모
- 분산환경에서도 동작해야하는지
- 애플리케이션 코드에 포함되어도 되는지 독립적 서비스인지
- 사용자에게 처리율 제한에 걸렸다는 사실을 알려야하는지

=> 예제에서의 요구사항  
설정된 처리율을 초과하는 요청은 정확하게 제한  
HTTP 응답시간에 악영향을 줘서는 안된다.  
가능한 적은 메모리의 사용  
분산처리율제한(하나의 처리율제한장치를 여러 서버나 프로세스에서 공유해야함)  
요청 제한시 사용자에게 예외처리해야함  
제한장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안 된다.  

### 2단계 개략적 설계안 제시 및 동의 구하기
클라이언트 요청은 쉽게 위변조가 가능하며 모든 클라이언트의 구현을 통제하는것이 어려움 -> 서버측? 다른방법?  
-> 미들웨어를 만들어 클라이언트-서버 사이 요청을 통제하는것도 가능  
클라우드 마이크로서비스의 경우 처리율제한장치가 api 게이트웨이라 불리는 컴포넌트에 구현되어 제한함  

#### 어디에 적용할것인지를 정하기위해 몇가지 지침을 나열해보자
기술스택 점검하여 서버측 구현을 지원하기 충분할정도로 효율이 높은지 확인  
사업필요에맞는 처리율 제한 알고리즘 찾기(3사업자가 제공하는 게이트웨이를 사용한다면 알고리즘이 제한적)  
마이크로 서비스에 기반하고있고 사용자인증이나 이용목록관리를 처리하기위해 api 게이트웨이를 설계에 포함시켰다면 처리율제한도 포함시켜야할수있음  
충분한 인력이 없다면 상용 api를 사용하기  

#### 처리율 제한 알고리즘
- 토큰버킷
- 누출버킷
- 고정 윈도 카운터
- 이동 윈도 로그
- 이동 윈도 카운터

#### 개략적 아키텍처
얼마나 많은 요청이 접수되었는지 추적할수있는 카운터를 추적대상별로 두고 카운터 값이 어떤 한도를 넘어서면 거부  
-> 카운터는 어디에 보관할것인가?  
-> DB는 느리니까 메모리상에 저장되는 캐시? -> 레디스!  
-> 레디스는 처리율 제한장치를 구현할 때 자주사용되는 메모리 기반 저장장치로서 INCR과 EXPIRE 두가지 명령어를 지원  
INCR : 메모리에 저장된 카운터의 값을 1 증가  
EXPIRE : 카운터에 타임아웃을 설정하여 시간이 지나면 카운터 자동 삭제  

### 3단계 상세설계
- 처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가?
- 처리가 제한된 요청들은 어떻게 처리하는가?

#### 처리율 제한 규칙
하루 5개 마케팅 메시지 제한 / 분당 5회 이상 로그인 횟수 제한 등

#### 처리율 한도 초과 트래픽 처리
HTTP 429(too many requests)응답을 클라이언트에 보내기(경우에 따라 한도제한 메시지의 추후처리를 위해 큐에 보관)  
처리율 제한에 걸리기까지 얼마나 많은 요청을 보낼수있는지에 관하여 HTTP 응답헤더를 이용할 수 있음  
- X-Ratelimit-Remaining : 윈도 내 남은 처리 가능 요청의 수  
- X-Ratelimit-Limit : 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수  
- X-Ratelimit-Retry-After : 한도 제한에 걸리지 않으려면 몇초뒤에 요청을 다시 보내야하는지  

#### 상세설계
처리율 제한 규칙은 디스크에 보관  
작업 프로세스는 수시로 규칙을 디스크에서 읽어 캐시에 저장  
클라이언트가 요청을 서버에 보내면 요청은 처리율제한 미들웨어에 도달하여  
처리율제한 미들웨어가 제한규칙을 캐시에서 가져오고,  
카운터 및 마지막 요청의 타임스탬프를 레디스 캐시에서 가져온다.  
가져온 값들에 근거하여 미들웨어는 처리율 제한이 걸리지않았을경우는 api서버로 요청을 보내고  
처리율제한에 걸린다면 429에러를 클라이언트에 보내며 해당요청은 메시지큐에 보관할 수도 있다.  

#### 분산 환경에서 처리율 제한 장치의 구현
생각해봐야할 점 : 경쟁조건, 동기화  

- 경쟁조건  
: 레디스에서 카운터 값을 읽는다 -> 카운터+1이 임계치를 넘는지 본다 -> 넘지않는다면 카운터값+1 의 과정에서  
병렬실행되었을경우 카운터의 갯수가 원래 증가되어야하는 값보다 적게 증가될 수 있음  
락은 시스템 성능을 떨어뜨리므로 루아스크립트와 정렬집합(sorted set)이라고 불리는 레디스 자료구조를 사용 가능하다.  

- 동기화  
: 처리율제한장치를 여러대 두게되면 동기화가 필요해지는데  
sticky session을 활용하여 항상 같은 처리율 제한장치로 보낼수있지만 이는 권장하지않으며  
레디스와 같은 중앙집중형데이터저장소를 쓰도록 한다.  

- 성능최적화  
: 여러 데이터 센터를 지원? -> 데이터센터에서 멀리떨어진 사용자를 지원하려다보면 latency 가 증가할수밖에 없음 -> 엣지서버를 통해 latency를 줄인다  
: 제한장치간 데이터를 동기화할때 **최종 일관성 모델**(ch06 참고)을 사용  

- 모니터링  
: 효과적으로 동작하는지 확인하기위해 데이터를 모아 확인하고 알고리즘을 변경하는 등의 수정을 할 수 있음  


### 4단계 마무리-추가적으로 언급하면 좋을 부분  
#### 경성/연성 처리율 제한  
- 경성 : 요청 갯수는 임계치를 절대 넘을 수 없음  
- 연성 : 요청 갯수는 잠시동안만 임계치를 넘어설 수 있음  

#### 다양한 계층에서의 처리율 제한  
iptables를 사용하면 IP주소에 처리율 제한을 적용하는 것이 가능하다.  

#### 처리율 제한을 회피하는 방법  
클라이언트는 어떻게 설계하는것이 최선일까?  
- 클라이언트 측 캐시를 사용하여 api 호출 횟수를 줄이기  
- 임계치를 이해하고 짧은 시간 동안 너무 많은 메시지를 보내지 않도록 한다.  
- 예외나 에러를 처리하는 코드를 도입하여 클라이언트가 예외적 상황으로부터 우아하게 복구될 수 있도록 한다  
- retry 로직을 구현할때에는 충분한 백오프 시간을 두기