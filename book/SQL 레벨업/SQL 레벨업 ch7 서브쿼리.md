# SQL 레벨업

## 21장  서브쿼리가 일으키는 폐해
### 18강 기능적 관점으로 구분하는 결합의 종류  
- 서브쿼리 : 비영속적인 생존기간(스코프)이 SQL 구문 실행 중으로 한정
- 뷰 : 영속적이지만 데이터는 저장하지 안흠. 따라서 접근할때마다 SELECT 구문이 실행됨
- 테이블 : 영속적인 데이터를 저장

#### 1. 서브쿼리의 문제점
서브쿼리의 성능적 문제는 결과적으로 서브쿼리가 실체적인 데이터를 저장하고 있지 않다는 점에서 기인.

이에 따른 세가지 문제점  
- 1. 연산 비용 추가  
: 서브쿼리에 접근할때마다 SELECT 구문을 실행해서 데이터를 만들어야하므로 비용이 추가된다.  
- 2. 데이터 I/O 비용 발생  
: 연산결과를 어딘가에 저장하기위해 써 둬야하므로 데이터 양이 큰 경우 DBMS가 저장소에 있는 파일에 결과를 쓸때에도 있다.  
- 3. 최적화를 받을 수 없음  
: 테이블과 다르게 명시적 제약 또는 인덱스가 작성되어있지 않아 옵티마이저가 쿼리를 해석하기 위해 필요한 정보를 얻을 수 없다.  
-> view merge를 이용하여 실행계획을 만드는 대책?

#### 2. 서브쿼리 의존증
구입 명세 테이블 Receipts

| cust_id | seq | price |
|---------|-----|-------|
| A       | 1   | 500   |
| A       | 2   | 1000  |
| A       | 3   | 700   |
| B       | 5   | 100   |
| B       | 6   | 5000  |
| B       | 7   | 300   |
| B       | 9   | 200   |
| B       | 12  | 1000  |
| C       | 10  | 600   |
| C       | 20  | 100   |
| C       | 45  | 200   |
| C       | 70  | 50    |
| D       | 3   | 2000  |

구하고자 하는 답 :  
| cust_id | seq | price |
|---------|-----|-------|
| A       | 1   | 500   |
| B       | 5   | 100   |
| C       | 10  | 600   |
| D       | 3   | 2000  |

서브쿼리를 사용한 방법은 다음과 같다.  
~~~sql
SELECT R1.cust_id, R1.seq, R1.price
FROM Receipts R1
  INNER JOIN
    (SELECT cust_id, MIN(seq) as min_seq
      FROM Receips 
      GROUP BY cust_id) R2
  ON R1.cust_id = R2.cust_id
    AND R1.seq = R2.min_seq;
~~~

이 방법의 단점은 코드가 복잡해서 가독성이 떨어진다는 점과, 성능이다.  
코드의 성능이 나쁜 이유로 4가지를 꼽을 수 있다.  
1. 서브쿼리는 대부분 일시적영역에 확보되므로 오버헤드가 생긴다.  
2. 서브쿼리는 인덱스 또는 제약정보를 가지지 않기때문에 최적화 되지 못한다.  
3. 이 쿼리는 조인을 필요로 하기때문에 비용이 높고 실행계획 변동리스크가 발생한다.  
4. Receipts 테이블에 스캔이 두 번 필요하다.  

그렇다고해서 상관서브쿼리는 답이 될 수 없다.  
~~~sql
SELECT cust_id, seq, price
FROM Receipts R1
WHERE seq = (SELECT MIN(seq)
              FROM Receipts R2
              WHERE R1.cust_id = R2.cust_id);
~~~

실행계획을 보면, 상관서브쿼리를 사용하더라도 테이블에 접근이 두 번 발생한다.  
(인덱스 온리 스캔을 사용하더라도 테이블 접근 1회+기본키인덱스접근1회)

이럴 경우, 윈도우 함수로 조인을 제거할 수 있다.  
Receipts 테이블에 대한 접근을 1회로 줄이기위해 ROW_NUMBER를 사용할 수 있다.  
~~~sql
SELECT cust_id, seq, price
FROM ( SELECT cust_id, seq, price,
              ROW_NUMBER() OVER (PARTITION BY cust_id
                                  ORDER BY seq) AS row_seq
        FROM Receipts) WORK
WHERE WORK.row_seq = 1
~~~  
각 구매 이력에 번호를 붙여서 고객들의 최초 구매이력을 쉽게 찾을 수 있도록 한다.  

#### 3. 장기적 관점에서의 리스크 관리
저장소의 I/O 양을 감소시키는 것이 튜닝의 가장 기본 원칙이다.  
예제에서 처음 사용했던 쿼리와 비교하면 조인을 사용한 부분을 윈도우 함수로 제거하였는데,  
이렇게 하면 성능향상뿐 아니라 안정성 확보도 기대할 수 있다.

- 조인쿼리의 불안정 요소 1 : 알고리즘 변동 리스크
- 불안정 요소 2 : 환경 요인에 의한 지연 리스크(인덱스, 메모리, 매개변수 등)

따라서 우리는 옵티마이저가 이해하기 쉽게 쿼리를 단순하게 작성해야한다.  
(실행계획이 단순할수록 성능이 안정적)

### 22강 서브쿼리 사용이 더 나은 경우
조인할때 최대한 조인 대상 레코드 수를 줄이는 것이 중요한데  
이럴 경우 서브쿼리를 사용하면 성능적으로 좋은 결과를 얻을 수 있다.

#### 1. 결합과 집약 순서
회사 테이블 Companies

| co_cd | district |
|-------|----------|
| 001   | A        |
| 002   | B        |
| 003   | C        |
| 004   | D        |

사업소 테이블 Shops

| co_cd | shop_id | emp_nbr | main_flg |
|-------|---------|---------|----------|
| 001   | 1       | 300     | Y        |
| 001   | 2       | 400     | N        |
| 001   | 3       | 250     | Y        |
| 002   | 1       | 100     | Y        |
| 002   | 2       | 20      | N        |
| 003   | 1       | 400     | Y        |
| 003   | 2       | 500     | Y        |
| 003   | 3       | 300     | N        |
| 003   | 4       | 200     | Y        |
| 004   | 1       | 999     | Y        |

-> 원하는 결과

| co_cd | district | sum_emp |
|-------|----------|---------|
| 001   | A        | 550     |
| 002   | B        | 100     |
| 003   | C        | 1100    |
| 004   | D        | 999     |

해당 결과를 만드는 방식으로는 두가지 방법이 있다.  
1. 조인부터 하고 집약  
2. 집약먼저하고 조인

~~~sql
-- 조인을 먼저 수행
SELECT C.co_cd, MAX(C.district),
      SUM(emp_nbr) AS sum_emp
FROM Companies C
    INNER JOIN Shops S
    ON C.co_cd = S.co_cd
WHERE main_flg = 'Y'
GROUP BY C.co_cd;

-- 집약을 먼저 수행
SELECT C.co_cd, C.district, sum_emp
FROM Companies C
    INNER JOIN (SELECT co_cd,
                      SUM(emp_nbr) AS sum_emp
                FROM Shops
                WHERE main_flg = 'Y'
                GROUP BY co_cd) CSUM
    ON C.co_cd = CSUM.co_cd;
~~~

두가지 방법은 성능적으로 큰 차이를 보일 수 있다. 판단기준은 '결합 대상 레코드 수'  
첫번째 방법의 경우 결합대상 레코드 수는 다음과 같다.  
- 회사 : 레코드 4개  
- 사업소 : 레코드 10개

두번째 방법의 경우 결합 대상 레코드 수는 다음과 같다.  
- 회사 : 레코드 4개
- 사업소 : 레코드 4개  

회사 테이블 규모에 비해 사업소 규모가 매우 크다면 조인대상레코드 수를 집약하는 편이 I/O 비용을 줄일 수 있을 것.  
두번째 방법에서 집약비용이 더 클 수 있지만 TEMP 탈락이 발생하지 않는다면 괜찮은 트레이드오프  
-> 튜닝 선택지 중 하나로 '사전에 조인 레코드 수를 압축한다'는 방법

### 마치며
- 서브쿼리는 복잡한 문제를 분할할 수 있는 편리한 도구이지만, 결합을 늘리는 성능 악화를 일으킬 수 있음
- SQL성능을 결정하는 요인은 I/O가 절대적
- 서브쿼리와 결합을 윈도우 함수로 대체하면 성능을 개선할 가능성이 있음
- 서브쿼리를 사용할때는 결합 대상 레코드 수를 사전에 압축해서 성능을 개선할 수 있음