# SQL 레벨업

## 6장  결합 : 결합을 지배하는 자가 SQL을 지배한다
### 18강 기능적 관점으로 구분하는 결합의 종류
결합Join 이름이 붙은 연산  
- cross join
- inner join
- outer join
- self join
- 등가 조인(Equi join)/ 비등가 조인(Non Equi-join)
- 자연 조인(Natural join)

#### 1. 크로스 조인 - 모든 조인의 모체
실무에서 사용할 기회는 거의 없을 것  
이유 1 : 크로스 조인의 결과가 필요한 경우가 없다.  
이유 2 : 비용이 매우 많이드는 연산이다.  

실무에서 나타나는 가장 흔한 경우는 오래된 조인 구문을 사용할 때 실수로 조인 조건을 적지 않을 때 이다.  
~~~sql
-- 실수로 사용한 크로스 조인 : WHERE 구로 조인 조건을 지정하지 않음
SELECT * FROM Employees, Departments;
~~~  
실수를 막으려면 표준 SQL에 맞게 구문을 사용하는 것이 좋다.

#### 2. 내부 조인
내부조인은 기능적으로 상관 서브쿼리를 사용해 대체 가능한 경우가 많다.  
그러나 기본적으로 조인을 사용하는 것이 성능상 좋다.  
~~~sql
-- 내부 조인
SELECT E.emp_id, E.emp_name, E.dept_id, D.dept_name
FROM Employees E INNER JOIN Departments D
ON E.dept_id = D.dept_id;

-- 상관 서브쿼리로 작성
SELECT E.emp_id, E.emp_name, E.dept_id, 
        (SELECT D.dept_name
            FROM Departments D
            WHERE E.dept_id = D.dept_id) AS dept_name
FROM Employees E;
~~~

#### 3. 외부 Join
외부조인의 종류  
- left outer join
- right outer join
- full outer join

마스터가 되는 테이블을 왼쪽에 적으면 left outer join  
오른쪽에 적으면 right outer join

#### 4. 외부조인과 내부 조인의 차이
cross join과 inner join 은 null을 생성하지 않는다.

#### 5. self join
자기 자신과 결합하는 연산.  
같은 테이블(또는 같은 뷰)를 사용해 결합한다.  

### 19강 결합 알고리즘과 성능
옵티마이저가 선택 가능한 결합알고리즘은 크게 세가지이다.  
1. Nested Loops  
2. Hash  
3. Sort Merge

Nested Loops는 가장 빈번하게 볼 수 있는 알고리즘으로 각종 join 알고리즘의 기본이 되는 알고리즘이다.  
DBMS 버전에 따라 알고리즘이 바뀌는 경우가 있으므로 사용하는 DBMS 최신 동향에 주의를 기울이도록 한다.  

#### 1. Nested Loops
세부처리는 구체적으로 다음과 같다.  
1. 조인 대상 테이블 (Tb1)에서 레코드를 하나씩 반복해가며 스캔한다. 이를 드라이빙 테이블이라고 부른다. 다른 테이블(Tb2)은 드리븐 테이블이라고 부른다.  
2. 드라이빙 테이블의 레코드 하나마다 드리븐 테이블의 레코드를 하나씩 스캔해서 조인 조건에 맞으면 리턴한다.  
3. 이러한 작동을 드라이빙 테이블의 모든 레코드에 반복한다.  

따라서 다음과 특징을 가진다.  
- Tb1, Tb2의 조인 대상 레코드를 R(A), R(B)라고 한다면 접근되는 레코드의 수는 R(A) * R(B) 가 된다.  
Nested 실행 시간은 이러한 레코드 수에 비례한다.  
- 한번의 단계에서 처리하는 레코드 수가 적으므로 메모리 소비가 비교적 적다.  
- 모든 DBMS에서 지원한다.  

Nested Loops의 성능을 개선하는 키워드로 '드라이빙 테이블로는 작은 테이블을 선택하는 것'이라는 말이 있다.  
드리븐 테이블의 조인키 필드에는 인덱스가 존재한다는 전제.  
인덱스가 존재한다면 해당 인덱스를 통해 드리븐 테이블을 완전 순환하지 않아도 된다.  
이상적인 경우 접근하는 레코드 수가 R(A) * 2 가 될 수 있다.  

단점으로는 조인키로 드리븐 테이블에 접근 시 히트되는 레코드가 너무 많다면 성능이 낮아진다는 점이 있으며  
이를 대처하기위해서 드라이빙테이블로 큰 테이블을 선택하거나, Hash를 사용하는 방법을 활용한다.

#### 2. Hash
해시 조인은 작은 테이블을 스캔하고 조인키에 해시함수를 적용해 해시값으로 변환한 뒤  
다른 테이블을 스캔하고 조인키가 해시값에 존재하는지를 확인하는 방법으로 조인을 수행한다.  

작은 테이블에서 해시테이블을 만드는 이유는 해시테이블은 워킹메모리에 저장되므로 작은것이 효율적이기 때문  

주요 특징은 다음과 같다.  
- 조인 테이블로부터 해시 테이블을 만들어 활용하므로 Nested Loops에 비해 메모리를 크게 소모한다.
- 메모리가 부족해지면 저장소를 사용하므로 지연 발생
- 출력되는 해시값은 입력값의 순서를 알지 못하므로 등치조인에만 사용가능

유용한 경우는 다음과 같다.
- Nested Loops에서 적절한 드라이빙 테이블이 존재하지 않는 경우
- 드리븐 테이블에서 히트되는 레코드 수가 너무 많은 경우
- 드리븐 테이블에 인덱스가 존재하지않는 경우

but 동시 실행성이 높은 OLTP 처리를 하는 경우 해시를 사용하면 DBMS가 사용할 수 있는 메모리가 부족해지므로 사용X  
테이블 풀 스캔이 사용되는 경우가 많으므로 시간을 고려해야 한다.

#### 3. Sort Merge
Merge Join이라 부르기도 한다.  
조인 대상 테이블들을 각각 조인키로 정렬하고, 일치하는 키를 찾으면 조인한다.  

주요 특징은 다음과 같다.  
- 대상 테이블을 모두 정렬해야하므로 많은 메모리를 소비한다.
- Hash와 다르게 부등호를 사용한 조인에도 사용할 수 있으나 <> 결합에서는 사용 불가.
- 테이블을 정렬하므로 한쪽 테이블을 모두 스캔한 시점에 조인을 완료할 수 있다.

#### 4. 의도치 않은 크로스 조인
예를 들어, Tb1,Tb2,Tb3 세 테이블을 조인한다고 할 때  
Tb1-Tb2, Tb1-Tb3끼리만 결합 조건이 존재할 경우  
실행계획으로 Nested Loops 가 아닌 크로스 조인이 선택될 수 있다.  
추측이지만 Tb2와 Tb3의 크기가 작다고 평가했을 가능성.  
이럴 경우 결합 조건이 존재하지 않는 테이블 사이 불필요한 결합조건을 추가하여 회피할수있다.

### 20강 결합이 느리다면
#### 1. 상황에 따른 최적의 결합 알고리즘
알고리즘의 장단점을 정리하면 다음과 같다.

| 이름 | 장점 | 단점 |
|--|--|--|
| Nested Loops | '작은 드라이빙 테이블' + '드리븐 테이블의 인덱스' 라는 조건이 있다면 굉장히 빠르다.  메모리 또는 디스크 소비가 적으므로 OLTP에 적합. 비등가 조인에도 사용가능| 대규모 테이블들의 결합에 부적합. 드리븐테이블의 선택률이 높거나 인덱스가 사용되지않으면 느리다. |
| Hash | 대규모 테이블 조인에 적합 | OLTP 부적합. 메모리 부족이 일어나면 TEMP 탈락 발생. 등가 조인에서만 사용 가능 |
| Sort Merge | 대규모 테이블 조인 적합. 비등가 조인에도 사용가능 | OLTP 부적합. 메모리 부족이 일어나면 TEMP 탈락 발생. 데이터가 정렬되어있지 않다면 비효율 |

최적의 조인 알고리즘을 조인 대상 레코드 수의 관점에서 정리하면 대충 다음과 같다.  
1. 소규모 - 소규모  
어떤 알고리즘을 사용해도 성능차이가 크지 않다.  
2. 소규모 - 대규모  
소규모 테이블을 드라이빙 테이블로하는 Nested Loops를 사용한다. 대규모 테이블의 조인키 인덱스를 만들어주도록한다.  
드리븐 테이블의 조인 대상 레코드가 너무 많다면 드라이빙테이블과 드리븐테이블을 바꾸거나 Hash사용 검토  
3. 대규모 - 대규모  
일단 Hash 사용. 처음부터 정렬되어 있는 상태라면 Sort Merge 사용

#### 2. 실행계획 제어
DBMS별로 다르지만 사용할수있으면 Hint 구를 사용하도록한다.  

### 마치며
- 조인은 SQL 성능문제의 화약고
- 기본은 Nested Loops. 배치 또는 BI/DWH에서는 Hash, Hash를 사용할때는 TEMP 탈락에 주의
- Nested Loops가 효율적으로 동작하려면 '작은 드라이빙 테이블'과 '드리븐 테이블의 인덱스'가 필요
- 조인은 알고리즘이 복잡하므로 실행계획 변동이 일어나기 쉽다. 이를 방지하려면 조인을 사용하지 않는것도 중요한 전략이다.
  -> 비정규화, 조인을 회피하기위한 대체 수단