# SQL 레벨업

## 1장  DBMS 아키텍처
### 1강 DBMS 아키텍처 개요
#### 1. 쿼리평가 엔진
SQL구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지 결정  
이때 결정 되는 계획 -> 실행계획  
계획을 세우고 실행하는 DBMS의 핵심기능을 담당하는 모듈  
#### 2. 버퍼매니저
버퍼 관리
#### 3. 디스크용량 매니저
어디에 어떻게 데이터를 저장할지 관리  
데이터의 읽고 쓰기를 제어
#### 4. 트랜잭션매니저와 락 매니저
트랜잭션의 정합성을 유지하면서 실행시키고, 필요한 경우 데이터에 락을 걸어 다른사람의 요청을 대기  
#### 5. 리커버리 매니저
데이터를 정기적으로 백업하고, 문제가 일어났을때 복구해주는 기능 수행

### 2강 DBMS와 버퍼
많은 데이터를 영속적으로 저장하려하면 속도를 잃고,  
속도를 얻고자 하면 많은 데이터를 영속적으로 저장하기 힘들다는 트레이드 오프가 발생한다.

#### DBMS가 데이터를 유지하기위해 사용하는 메모리의 종류 두가지
- 데이터 캐시 :디스크에 있는 데이터 일부를 메모리에 유지하기 위해 사용하는 메모리 영역
- 로그버퍼
: 갱신처리(INSERT,DELETE,UPDATE,MERGE)와 관련있음  
갱신 SQL구문을 사용자로부터 받으면 로그버퍼 위에 변경정보를 보내고 이후 디스크에 변경을 수행

기본적으로 데이터캐시에비해 로그버퍼가 초기값이 굉장히 작은데 이는 기본적으로 검색을 메인으로 처리한다고 가정하기 때문.  
로그버퍼가 크게 잡혀있다면, 갱신처리와 관련해 큰 부하가 걸릴것을 고려한 설계

#### 워킹메모리
: 정렬 또는 해시관련 처리에 사용되는 작업용 영역
메모리가 부족할 경우 저장소를 사용한다.

### 3강 DBMS와 실행계획
#### 데이터에 접근하는 방법
- 파서 : 구문분석 역할
- 옵티마이저 : 실행계획 최적화(실행계획작성, 비용연산, 실행계획 선택)
- 카탈로그 매니저 : 통계정보(실행계획 세울때 필요한 정보)
- 플랜평가 : 최적의 실행결과 선택

#### 옵티마이저 통계 정보
구현에 따라 차이는 있지만 카탈로그에 포함되어있는 통계정보는 다음과 같은 것들이다.
- 각 테이블의 레코드 수
- 각 테이블의 필드 수와 필드의 크기
- 필드의 카디널리티(값의 개수)
- 필드값의 히스토그램(어떤값이 얼마나 분포되어있는가)
- 필드내부에 있는 NULL의 수
- 인덱스 정보

카탈로그정보와 실제가 일치하지않을경우 잘못된 실행계획을 세우게 된다.

#### 최적의 실행계획이 작성되게 하려면?
테이블의 데이터가 많이바뀌면 카탈로그 통계정보도 함께 갱신  
수동갱신  
데이터를 크게 갱신하는 배치 처리가 있을 때 Job Net을 조합  

### 대표적인 통계정보갱신명령어
- MySQL : ANALYZE TABLE [스키마이름].[테이블이름];

### 실행계획이 SQL 구문의 성능을 결정
#### 실행계획 확인 방법
SQL 구문 지연이 발생했을 때 제일먼저 실행계획을 살펴봐야한다.  

- MySQL : EXPLAIN EXTENDED SQL 구문

#### 테이블 풀 스캔의 실행계획
거의 모든 DBMS의 실행계획에 포함되어있는 중요한 정보 3가지  
1. 조작대상객체  
2. 객체에 대한 조작의 종류(가장 중요)  
3. 조작 대상이 되는 레코드 수  

60개의 정보를 저장한 Shops테이블이 있다고 가정  
~~~sql
create table Shops(
     shop_id int not null auto_increment,
     shop_name varchar(20) not null,
     rating int,
     area varchar(20),
    
     primary key (shop_id)
);


DELIMITER $$
CREATE PROCEDURE insertData()
BEGIN
    DECLARE i INT DEFAULT 1;
    WHILE i <= 60 DO
        INSERT INTO Shops (shop_name) VALUES ( CONCAT('shop',i) );
        SET i = i + 1;
    END WHILE;
END$$
DELIMITER ;

CALL insertData();
~~~  
~~~sql
SELECT * FROM Shops;
~~~
조작대상객체 : shops
객체에 대한 조작의 종류: 테이블 풀 스캔 (type:ALL)
조작 대상이 되는 레코드 수:60  
통계 정보에서 파악한 숫자이므로 테이블 레코드 수와 차이가 있을 수 있음으로 주의한다.  

#### 인덱스 스캔의 실행 계획
~~~sql
SELECT *
FROM Shops
WHERE shop_id = 50;
~~~
조작 대상이 되는 레코드 수 : 1  
조작대상객체와 조작 : 기본 키 또는 유니크키에 의한 loockup (type:const)

#### 간단한 테이블 결합의 실행계획
일반적으로 DBMS가 결합할때 사용하는 세가지 알고리즘  
1. NestedLoops  
가장 간단한 결합 알고리즘  
한쪽 테이블을 읽으며 레코드 하나마다 결합 조건에 맞는 레코드를 다른쪽 테이블에서 찾는 방식  
2. Sort Merge  
3. Hash  

### 마치며
- 데이터베이스는 다양한 트레이드오프의 균형을 잡으려는 미들웨어
- 성능적 관점에서는 데이터를 저속의 저장소(디스크)와 고속의 메모리 중 어디에 위치시킬지 트레이드 오프가 중요
- 데이터 베이스는 갱신보다 검색에 관련된 것에 비중을 주도록 기본 설정되어있지만 실제 시스템에서도 그럴지는 판단이 필요
- 데이터베이스는 SQL을 실행가능한 절차로 변환하고자 실행계획을 만듦

### 연습문제
DBMS의 데이터 캐시는 용량이 한정되어 있는 메모리에서 효율적으로 데이터를 유지하고자 다양한 알고리즘을 사용한다. 자신이 사용하는 DBMS에서는 어떤 알고리즘을 채택해서 사용하는지 알아보기  
-> 불특정 다수의 사용자로부터 요구되는 데이터의 캐시 히트율을 높이기 위해 기본적으로 LRU를 사용한다.  
-> LRU : 참조빈도가 가장 적은 것을 캐시에서 버리는 알고리즘.  
-> Mysql innodb: 변형된 LRU  