# SQL 레벨업

## 10장 인덱스 사용 : 균형의 약점
### 34강 인덱스와 B-tree
RDB에서 사용하는 인덱스는 다음과 같이 세가지로 분류할 수 있다.

- B-tree 인덱스
- 비트맵 인덱스
- 해시 인덱스

#### 1. 만능형 : B-tree
가장 많이 사용되는 균형잡히고 뛰어난 범용성의 인덱스  
검색 알고리즘으로서는 뛰어나게 성능이 좋은 편은 아니지만 균형이 잘 잡혀있기 때문에 사용된다.  
사실 대부분의 DB에서는 트리의 리프 노드에만 키값을 저장하는 B+tree라는 B-tree의 수정버전을 채택하는데,  
이는 B-tree에 비해 검색을 보다 효율적으로 만든 알고리즘이다.

B+tree는 루프와 리프의 거리를 가능한 일정하게 유지하려 하므로 균형이 잘 잡혀 검색성능이 안정적이다.  
트리의 깊이도 3-4 수준으로 일정하며 데이터가 정렬상태를 유지하므로 이분탐색을 통해 검색비용을 크게 줄일수 있다.  

#### 2. 기타인덱스
- 비트맵 인덱스    
: 데이터를 비트 플래그로 변환해서 저장하는 형태. 빈번한 갱신이 일어나지 않는 BI/DWH 용도로 사용된다.

- 해시 인덱스  
: 키를 해시분산하여 등가 검색을 고속으로 실행

### 35강 인덱스를 잘 활용하려면
인덱스를 잘 활용하려면 몇가지 포인트를 고려해야 한다.  
#### 1. 카디널리티와 선택률
어떤 필드에 대해 인덱스를 작성할 것인지 기준이 되는 요소

- 카디널리티 : 값의 균형을 나타내는 개념으로,  
카디널리티가 높으면 모든 레코드에 다른 값이 들어가있고, 카디널리티가 낮으면 모든 레코드에 같은 값이 들어가 있다.  
- 선택률 : 특정 필드값을 지정했을 때 테이블 전체에서 몇 개의 레코드가 선택되는지를 나타내는 개념  
전체 레코드 중에서 조건절에 의해 선택될 것으로 예상되는 레코드의 비율(%)  
선택률 = 카디널리티 / 총 레코드 수 * 100  

##### 클러스터링 팩터(clustering factor)
저장소에 같은 값이 어느 정도 물리적으로 뭉쳐 존재하는지를 나타내는 지표(높을수록 분산, 낮을수록 뭉쳐있음)  
보통 클러스터링 팩터가 낮을 수록 접근할 데이터 양이 적어져 좋다.  
데이터의 물리적 위치는 구현에 의존한다.  

#### 2. 인덱스를 사용하는 것이 좋은지 판단하려면
카디널리티가 높은것(값이 평균치에서 많이 흩어져있을 수록 좋다)  
선택률이 낮은것  

### 36강 인덱스로 성능 향상이 어려운 이유
인덱스 설계란 테이블 정의와 SQL만 봐서 할 수 있는 작업이 아니다.  
효율적으로 압축할 수 있는 조건을 찾기 위해 SQL구문과 검색 키 필드의 카디널리티를 알아야한다.  
그러나 압축할 조건이 해당 SQL 구문에 존재하지 않는다면?

#### 1. 압축 조건이 존재하지 않음
WHERE 구가 없는 SELECT의 구문의 경우 압축 조건이 존재하지 않는다.  
그러나 실무에서 이런 극단적인 경우는 거의 없고  
설령 이러한 처리가 필요한 경우는 특이한 형태의 배치처리로 속도가 크게 중요치 않을 것

#### 2. 레코드를 제대로 압축하지 못하는 경우
~~~sql
SELECT order_id, receive_date
FROM Orders
WHERE process_flg = '5';
~~~

테이블에서 process_flg분포가 다음과 같다고 가정  
- 1(주문단계) : 200만 건
- 2(주문완료) : 500만 건
- 3(재고확인중) : 500만 건
- 4(배송준비중) : 500만 건
- 5(배송완료) : 8,900만 건

process_flg필드에 인덱스를 만들면 그것을 사용하더라도 풀 스캔을 할때보다 느려질 가능성이 크다.  
인덱스가 제대로 작동하려면 레코드를 크게 압축할 수 있는 검색조건이 있어야하는데,  
이처럼 _flg 또는 _status가 필드명에 붙어있다면 특정 종류만을 지정하는 경우가 많고 종류의 수가 적기때문에  
인덱스로 만들기에 적절치 않은 필드이다.  

##### 입력 매개변수에 따라 선택률이 변동하는 경우
기간의 범위 검색과 같은 경우와 같이  
검색 조건이 매개변수화 되어있는 SQL은 그때그때 입력에 따라 선택률이 높아지거나 낮아진다.

#### 3. 인덱스를 사용하지 않는 검색 조건
- 중간일치, 후방일치의 LIKE 연산자 : 인덱스는 전방일치('대공원%')에만 적용할 수 있다.
- 인덱스 필드로 연산하는 경우(함수를 사용하는 경우 포함)
- IS NULL을 사용하는 경우
- 부정형(<>,!=,NOT IN) 을 사용하는 경우

### 37강 인덱스를 사용할 수 없는 경우 대처법
위와같이 인덱스를 사용하지못하거나, 인덱스를 사용하면 오히려 느려지는 SQL구문의 성능은 어떻게 튜닝해야할까?  
첫번째는 애플리케이션에서의 설정으로 처리하는 방법과  
두번째로 인덱스 온리 스캔을 사용하는 방식이 있다.

#### 1. 외부설정으로 처리 - 깊고 어두운 강 건너기
UI 설계로 처음부터 이러한 쿼리가 실행되지 않게 애플리케이션에서 제한하는 방식

#### 2. 외부 설정을 사용한 대처 방법의 주의점
데이터베이스 기술자와 애플리케이션 엔지니어는 완전 분업하기때문에 커뮤니케이션단절이 일어나기 쉬우므로,  
외부 설계를 사용한 대처에 실패, 선택률을 낮출 수 없는 경우가 굉장히 많다.  
따라서 프로젝트 시작 단계에서부터 합의해야하고,  
테스트 단계에서 성능 문제가 발생된다면 외부 설정 변경은 배제한 채로 시스템을 튜닝해야한다.

#### 3. 데이터 마트로 대처
개요 테이블 Summary Table이라고도 부르는 데이터마트는  
특정한 쿼리에서 필요한 데이터만을 저장하는, 상대적으로 작은 크기의 테이블을 의미한다.  

#### 4. 데이터 마트를 채택할 시 주의점
총 4가지의 주의할 포인트가 있다.
- 데이터 신선도 : 동기 시점의 문제  
테이블의 부분적인 복사본으로 동기시점이 빈번하면 성능문제가, 그렇지않다면 신선도문제가 발생  
- 데이터 마트 크기 
: 원래 테이블에서 크기를 딱히 줄일 수 없다면 무소용  
다만 GROUP BY 절을 미리 사용하여 집계를 마치고 데이터마트를 만들면 효과적이다.  
- 데이터 마트 수  
: 마트의 수를 너무 늘리면 관리가 불가능해지므로 지나치게 의존하는것은 좋지않음  
- 배치 윈도우  
: 배치윈도우와 Job Net도 고려해야한다.

#### 5. 인덱스 온리 스캔으로 대처
인덱스를 사용한 고속화 방법으로서  
SQL구문에서 필요한 필드를 인덱스만으로 커버할수있는 경우 테이블 접근을 생략하는 기술이다.  
이러한 인덱스를 커버링 인덱스라고 부른다.  
~~~sql
-- 압축 조건이 존재하지 않는 경우 (테이블풀스캔)
SELECT order_id, receive_date FROM Orders;

-- 커버링 인덱스
CREATE INDEX CoveringIndex ON Orders (order_id, receive_date);
~~~

I/O 비용을 줄일 수 있다는 장점

#### 6. 인덱스 온리 스캔의 주의사항
- DBMS에 따라 사용할 수 없는 경우도 있다.
- 한 개의 인덱스에 포함할 수 있는 필드 수에 제한이 있다.  
: 애시당초 인덱스의 크기가 너무 커지면, 물리 I/O를 줄이겠다는 당초의 목적이 희미해진다.  
- 갱신 오버 헤드가 커진다
- 정기적인 인덱스 리빌드가 필요  
: 일반적 인덱스보다도 크기에 민감하게 성능이 반응하므로,  
커버링 인덱스의 정기적 크기 모니터링과 리빌드를 운용에 포함시켜야한다.  
- SQL 구문에 새로운 필드가 추가된다면 사용할 수 없다.

### 마치며
- B+tree 인덱스는 편리하지만, 카디널리티와 선택률에 따라 성능이 결정
- 선택률을 제어하려면 UI 설계까지도 변경할 필요가 있음
- 선택률이 높은 경우에는 인덱스 온리 스캔을 활용
- 결국 인덱스를 사용한 성능 개선도 I/O 비용을 줄이기 위한 노력